#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const ora = require('ora');
const dotenv = require('dotenv');

console.log(chalk.blue.bold('\nüìÑ Setting up environment configuration...\n'));

// Check for force flag
const forceUpdate = process.argv.includes('--force') || process.argv.includes('-f');
if (forceUpdate) {
  console.log(chalk.yellow('‚ö†Ô∏è  Force update mode - will overwrite existing files\n'));
}

// First, check if .env.example exists
const envExamplePath = path.join(process.cwd(), '.env.example');
if (!fs.existsSync(envExamplePath)) {
  console.error(chalk.red('‚ùå .env.example not found in project root!'));
  console.log(chalk.yellow('Please ensure .env.example exists before running this script.'));
  process.exit(1);
}

// Create main .env from .env.example if it doesn't exist
const mainEnvPath = path.join(process.cwd(), '.env');
const mainEnvSpinner = ora('Creating main .env file...').start();

if (fs.existsSync(mainEnvPath)) {
  mainEnvSpinner.warn(chalk.yellow('.env already exists, skipping'));
} else {
  try {
    fs.copyFileSync(envExamplePath, mainEnvPath);
    mainEnvSpinner.succeed(chalk.green('.env created from .env.example'));
    console.log(chalk.cyan('   ‚Üí Please update .env with your actual values'));
  } catch (error) {
    mainEnvSpinner.fail(chalk.red('Failed to create .env'));
    console.error(error);
    process.exit(1);
  }
}

// Load the main .env file
const envConfig = dotenv.config({ path: mainEnvPath });
if (envConfig.error) {
  console.error(chalk.red('‚ùå Failed to load .env file:'), envConfig.error);
  process.exit(1);
}

const env = envConfig.parsed || {};

// Define package-specific env files that inherit from main .env
const packageEnvConfigs = [
  {
    path: 'packages/nextjs/.env.local',
    description: 'Next.js local overrides only',
    getContent: (env) => `# Next.js Local Environment Overrides
# This file is for local overrides only
# All values are inherited from root .env automatically via env.config.js
# Only add values here if you need to override the root configuration

# Example override (uncomment to use):
# NEXT_PUBLIC_FRONTEND_URL=http://localhost:3001
`
  },
  {
    path: 'packages/hardhat/.env',
    description: 'Hardhat smart contract configuration',
    getContent: (env) => `# Hardhat Environment Variables
# This file inherits from root .env
# Only override values here if needed for local development

# Deployment Configuration
DEPLOYER_PRIVATE_KEY=${env.DEPLOYER_PRIVATE_KEY || '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'}

# Network RPC URLs
BASE_RPC_URL=${env.BASE_RPC_URL || 'https://mainnet.base.org'}
BASE_SEPOLIA_RPC_URL=${env.BASE_SEPOLIA_RPC_URL || 'https://sepolia.base.org'}
LOCALHOST_RPC_URL=${env.LOCALHOST_RPC_URL || 'http://localhost:8545'}

# API Keys
ALCHEMY_API_KEY=${env.ALCHEMY_API_KEY || ''}
INFURA_API_KEY=${env.INFURA_API_KEY || ''}
ETHERSCAN_API_KEY=${env.ETHERSCAN_API_KEY || ''}
ETHERSCAN_V2_API_KEY=${env.ETHERSCAN_V2_API_KEY || env.ETHERSCAN_API_KEY || ''}
BASESCAN_API_KEY=${env.BASESCAN_API_KEY || ''}
ONEINCH_API_KEY=${env.ONEINCH_API_KEY || ''}

# Deployment Configuration
DEPLOYER_PRIVATE_KEY_ENCRYPTED=${env.DEPLOYER_PRIVATE_KEY_ENCRYPTED || ''}

# Development Settings
REPORT_GAS=${env.REPORT_GAS || 'true'}
HARDHAT_PORT=${env.HARDHAT_PORT || '8545'}
`
  },
  {
    path: '1balancer-near/.env',
    description: 'NEAR Protocol configuration',
    getContent: (env) => `# NEAR Environment Variables
# This file inherits from root .env
# Only override values here if needed for local development

# NEAR Configuration
NEAR_ENV=${env.NEAR_ENV || 'localnet'}
NEAR_NETWORK_ID=${env.NEAR_NETWORK_ID || 'localnet'}

# Contract Names
CONTRACT_NAME=${env.NEAR_HTLC_CONTRACT_NAME || 'fusion-plus-htlc.test.near'}
SOLVER_CONTRACT_NAME=${env.NEAR_SOLVER_CONTRACT_NAME || 'solver-registry.test.near'}
MASTER_ACCOUNT_ID=${env.NEAR_MASTER_ACCOUNT_ID || 'test.near'}

# Service Ports
BRIDGE_PORT=${env.NEAR_BRIDGE_PORT || '8090'}
SOLVER_PORT=${env.SOLVER_PORT || '8091'}
NEAR_LOCAL_PORT=${env.NEAR_LOCAL_PORT || '3030'}

# MPC Configuration
MPC_CONTRACT_ID=${env.NEAR_MPC_CONTRACT_ID || 'v1.signer.testnet'}
`
  },
  {
    path: 'packages/orchestrator/.env.test',
    description: 'Orchestrator test environment configuration',
    getContent: (env) => `# =============================================================================
# ORCHESTRATOR TEST ENVIRONMENT CONFIGURATION
# =============================================================================
# This file is automatically generated from root .env
# Configuration for running orchestrator integration and unit tests

# Service Configuration
NODE_ENV=test
PORT=8080
WS_PORT=8081
LOG_LEVEL=error

# Network Configuration (Test Networks)
BASE_RPC_URL=${env.BASE_SEPOLIA_RPC_URL || 'https://sepolia.base.org'}
NEAR_RPC_URL=${env.NEAR_RPC_URL || 'https://rpc.testnet.near.org'}
ETHEREUM_RPC_URL=${env.ETHEREUM_RPC_URL || 'https://eth-sepolia.g.alchemy.com/v2/test-key'}

# Security (Test Values)
API_KEY_SECRET=test-api-key-secret
JWT_SECRET=test-jwt-secret
CORS_ORIGIN=http://localhost:3000

# External Services (Test Mode)
ONEINCH_API_KEY=${env.ONEINCH_API_KEY || 'test-api-key'}
ONEINCH_API_URL=https://api.1inch.dev
# Session storage uses in-memory by default (Redis not required)
# REDIS_URL=redis://localhost:6379  # Uncomment if Redis is needed in the future

# Test Contract Addresses (Zero addresses for testing)
ESCROW_FACTORY_ADDRESS=0x0000000000000000000000000000000000000000
FUSION_PLUS_HUB_ADDRESS=0x0000000000000000000000000000000000000000
FUSION_PLUS_RESOLVER_ADDRESS=0x0000000000000000000000000000000000000000
LIMIT_ORDER_PROTOCOL_ADDRESS=0x111111125421ca6dc452d289314280a0f8842a65

# NEAR Configuration (Test)
NEAR_NETWORK_ID=testnet
NEAR_ORCHESTRATOR_ACCOUNT_ID=orchestrator.testnet
NEAR_PRIVATE_KEY=ed25519:test-private-key

# Monitoring (Disabled for tests)
METRICS_ENABLED=false
METRICS_PORT=9090
SENTRY_DSN=

# Rate Limiting (Relaxed for tests)
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=1000

# Chain Monitoring (Faster polling for tests)
BLOCK_POLLING_INTERVAL=1000
EVENT_CONFIRMATION_BLOCKS=1
MAX_REORG_DEPTH=5

# Session Configuration (Shorter timeouts for tests)
SESSION_TIMEOUT_SECONDS=300
MAX_ACTIVE_SESSIONS=100
SESSION_CLEANUP_INTERVAL=30000

# Dutch Auction Configuration (Faster for tests)
DUTCH_AUCTION_DURATION_SECONDS=60
DUTCH_AUCTION_START_PREMIUM=0.01
DUTCH_AUCTION_END_DISCOUNT=0.01
`
  }
];

// Create package-specific env files
console.log(chalk.cyan('\nüì¶ Creating package-specific environment files...\n'));

let createdCount = 0;
let skippedCount = 0;

for (const config of packageEnvConfigs) {
  const spinner = ora(`Creating ${config.path}...`).start();
  const fullPath = path.join(process.cwd(), config.path);
  const dir = path.dirname(fullPath);

  try {
    // Check if file already exists
    if (fs.existsSync(fullPath) && !forceUpdate) {
      spinner.warn(chalk.yellow(`${config.path} already exists, skipping (use --force to overwrite)`));
      skippedCount++;
      continue;
    }

    // Create directory if it doesn't exist
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Generate content using values from main .env
    const content = config.getContent(env);
    
    // Write the file
    fs.writeFileSync(fullPath, content);
    spinner.succeed(chalk.green(`${config.path} created - ${config.description}`));
    createdCount++;
  } catch (error) {
    spinner.fail(chalk.red(`Failed to create ${config.path}`));
    console.error(chalk.red(`  Error: ${error.message}`));
  }
}

console.log(chalk.green.bold(`\n‚úÖ Environment setup complete!`));
console.log(chalk.gray(`   Created: ${createdCount + (mainEnvPath ? 1 : 0)} files`));
console.log(chalk.gray(`   Skipped: ${skippedCount + (mainEnvPath ? 0 : 1)} files (already exist)\n`));

// Check for missing required values
console.log(chalk.yellow('‚ö†Ô∏è  Important next steps:\n'));

const requiredKeys = [
  { key: 'ONEINCH_API_KEY', description: 'Get from ETHGlobal hackathon process or 1inch team' },
  { key: 'ALCHEMY_API_KEY', description: 'Get from https://www.alchemy.com/ (required for production)' },
  { key: 'NEXT_PUBLIC_PRIVY_APP_ID', description: 'Get from https://console.privy.io and enable Ethereum wallets' },
  { key: 'NEXT_PUBLIC_PROXY_URL', description: 'Deploy proxy from github.com/Tanz0rz/1inch-vercel-proxy' }
];

let missingKeys = false;
for (const { key, description } of requiredKeys) {
  if (!env[key] || env[key].includes('your-') || env[key].includes('here')) {
    console.log(chalk.white(`   ‚Ä¢ Update ${chalk.cyan(key)} in .env`));
    console.log(chalk.gray(`     ${description}\n`));
    missingKeys = true;
  }
}

if (!missingKeys) {
  console.log(chalk.green('   All required keys are configured! üéâ\n'));
} else {
  console.log(chalk.white('After updating .env, run this script again to regenerate package configs.\n'));
}