{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/mocks/MockAggregationRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title MockAggregationRouter\n * @notice Mock implementation of 1inch Aggregation Router for testing\n */\ncontract MockAggregationRouter {\n    // Minimal implementation for testing\n    function swap(bytes calldata /* data */) external payable returns (uint256 returnAmount) {\n        // Mock implementation\n        returnAmount = 1000;\n    }\n    \n    function unoswap(address /* srcToken */, uint256 /* amount */, uint256 /* minReturn */, bytes32[] calldata /* pools */) external payable returns (uint256 returnAmount) {\n        // Mock implementation\n        returnAmount = 1000;\n    }\n}"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MockERC20\n * @notice Mock ERC20 token for testing\n */\ncontract MockERC20 is ERC20, Ownable {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals_\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyOwner {\n        _burn(from, amount);\n    }\n}"
    },
    "contracts/mocks/MockLimitOrderProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\nimport \"../portfolio/interfaces/ILimitOrderProtocol.sol\";\n\n/**\n * @title MockLimitOrderProtocol\n * @dev Mock implementation of ILimitOrderProtocol for testing\n */\ncontract MockLimitOrderProtocol is ILimitOrderProtocol {\n    mapping(bytes32 => bool) public filledOrders;\n    mapping(bytes32 => Order) public orders;\n    \n    event MockOrderFilled(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address indexed taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount\n    );\n\n    function fillOrderArgs(\n        Order calldata order,\n        bytes32 /* r */,\n        bytes32 /* vs */,\n        uint256 /* amount */,\n        TakerTraits calldata /* takerTraits */,\n        bytes calldata /* args */\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        orderHash = calculateOrderHash(order);\n        \n        // Mock fill logic\n        if (!filledOrders[orderHash]) {\n            filledOrders[orderHash] = true;\n            orders[orderHash] = order;\n            \n            makingAmount = order.makingAmount;\n            takingAmount = order.takingAmount;\n            \n            emit MockOrderFilled(\n                orderHash,\n                order.maker,\n                msg.sender,\n                makingAmount,\n                takingAmount,\n                0 // remaining making amount\n            );\n        }\n    }\n\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata /* signature */,\n        uint256 /* amount */,\n        TakerTraits calldata /* takerTraits */,\n        bytes calldata /* args */\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        orderHash = calculateOrderHash(order);\n        \n        // Mock fill logic for contract orders\n        if (!filledOrders[orderHash]) {\n            filledOrders[orderHash] = true;\n            orders[orderHash] = order;\n            \n            makingAmount = order.makingAmount;\n            takingAmount = order.takingAmount;\n            \n            emit MockOrderFilled(\n                orderHash,\n                order.maker,\n                msg.sender,\n                makingAmount,\n                takingAmount,\n                0 // remaining making amount\n            );\n        }\n    }\n\n    function cancelOrder(bytes32 orderHash, uint256 /* makerTraits */) external {\n        // Mock cancellation\n        filledOrders[orderHash] = true; // Mark as cancelled\n    }\n\n    function calculateOrderHash(Order memory order) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            order.salt,\n            order.maker,\n            order.receiver,\n            order.makerAsset,\n            order.takerAsset,\n            order.makingAmount,\n            order.takingAmount,\n            order.makerTraits\n        ));\n    }\n\n    function isOrderFilled(bytes32 orderHash) external view returns (bool) {\n        return filledOrders[orderHash];\n    }\n\n    function getOrder(bytes32 orderHash) external view returns (Order memory) {\n        return orders[orderHash];\n    }\n} "
    },
    "contracts/mocks/MockSpotPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../portfolio/interfaces/ISpotPriceAggregator.sol\";\n\ncontract MockSpotPriceAggregator is Ownable {\n    // Mapping from token pair to mock price (token1 => token2 => price)\n    mapping(address => mapping(address => uint256)) public mockPrices;\n    // Mapping from token to ETH price\n    mapping(address => uint256) public mockEthPrices;\n    \n    // ETH address (will be set during deployment)\n    address public wethAddress;\n\n    constructor(address initialOwner) Ownable(initialOwner) {\n        // No hardcoded initialization - prices will be set via external calls\n    }\n\n    function setWethAddress(address _wethAddress) external onlyOwner {\n        wethAddress = _wethAddress;\n    }\n\n    function getRate(\n        address srcToken,\n        address dstToken,\n        bool /* useWrappers */\n    ) external view returns (uint256) {\n        if (srcToken == dstToken) return 1e18;\n        \n        uint256 price = mockPrices[srcToken][dstToken];\n        require(price > 0, \"MockSpotPriceAggregator: Price not set\");\n        return price;\n    }\n\n    function getRateToEth(\n        address srcToken,\n        bool /* useSrcWrappers */\n    ) external view returns (uint256) {\n        if (srcToken == wethAddress) return 1e18;\n        \n        uint256 price = mockEthPrices[srcToken];\n        require(price > 0, \"MockSpotPriceAggregator: ETH price not set\");\n        return price;\n    }\n\n    // Owner functions to manipulate prices for testing\n    function setMockPrice(address srcToken, address dstToken, uint256 price) external onlyOwner {\n        mockPrices[srcToken][dstToken] = price;\n    }\n\n    function setMockEthPrice(address token, uint256 price) external onlyOwner {\n        mockEthPrices[token] = price;\n    }\n\n    // Helper functions for testing stablecoin deviations\n    function setStablecoinDeviation(address stablecoin1, address stablecoin2, uint256 deviationBps) external onlyOwner {\n        // deviationBps: 100 = 1%, 50 = 0.5%\n        uint256 basePrice = 1e18;\n        uint256 deviatedPrice = basePrice + (basePrice * deviationBps) / 10000;\n        \n        mockPrices[stablecoin1][stablecoin2] = deviatedPrice;\n        mockPrices[stablecoin2][stablecoin1] = (1e36) / deviatedPrice;\n    }\n\n    function resetStablecoinPrices() external onlyOwner {\n        // This function is now a placeholder - specific stablecoin addresses need to be provided\n        // The actual reset will be done via setMockPrice calls with the deployed token addresses\n    }\n\n    // Batch price setting for efficiency\n    function setBatchPrices(\n        address[] calldata srcTokens,\n        address[] calldata dstTokens,\n        uint256[] calldata prices\n    ) external onlyOwner {\n        require(\n            srcTokens.length == dstTokens.length && dstTokens.length == prices.length,\n            \"MockSpotPriceAggregator: Array lengths mismatch\"\n        );\n        \n        for (uint256 i = 0; i < srcTokens.length; i++) {\n            mockPrices[srcTokens[i]][dstTokens[i]] = prices[i];\n        }\n    }\n\n    // Batch ETH price setting\n    function setBatchEthPrices(\n        address[] calldata tokens,\n        uint256[] calldata prices\n    ) external onlyOwner {\n        require(tokens.length == prices.length, \"MockSpotPriceAggregator: Array lengths mismatch\");\n        \n        for (uint256 i = 0; i < tokens.length; i++) {\n            mockEthPrices[tokens[i]] = prices[i];\n        }\n    }\n}\n"
    },
    "contracts/portfolio/balancers/OptimizedDriftBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../modules/OptimizedBaseBalancer.sol\";\n\ncontract OptimizedDriftBalancer is OptimizedBaseBalancer {\n    uint256 public driftPercentage;\n\n    event DriftPercentageUpdated(uint256 newDriftPercentage);\n    event RebalanceNeeded(address[] tokens, uint256[] deviations);\n\n    constructor(\n        address _owner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256 _driftPercentage,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol\n    ) OptimizedBaseBalancer(_owner, _factory, _assetAddresses, _percentages, _stablecoins, _limitOrderProtocol) {\n        driftPercentage = _driftPercentage;\n    }\n\n    function triggerRebalance() external {\n        _checkAndTriggerRebalance();\n    }\n\n    function updateDriftPercentage(uint256 _newDriftPercentage) external onlyOwner {\n        driftPercentage = _newDriftPercentage;\n        emit DriftPercentageUpdated(_newDriftPercentage);\n    }\n\n    function _checkAndTriggerRebalance() internal {\n        uint256 totalValue = getTotalValue();\n        if (totalValue == 0) return;\n\n        uint256[] memory groupDeviations = new uint256[](assetGroupsCount);\n        address[][] memory groupTokens = new address[][](assetGroupsCount);\n        \n        bool rebalanceNeeded = false;\n        \n        for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n            AssetGroup memory group = assetGroups[groupId];\n            uint256 groupValue = 0;\n            \n            // Calculate total value for this group\n            for (uint256 i = 0; i < group.tokens.length; i++) {\n                uint256 balance = IERC20(group.tokens[i]).balanceOf(address(this));\n                groupValue += getPrice(group.tokens[i], balance);\n            }\n            \n            uint256 currentPercentage = (groupValue * 100) / totalValue;\n            uint256 targetPercentage = group.percentage;\n            \n            // Calculate deviation\n            uint256 deviation = currentPercentage > targetPercentage \n                ? currentPercentage - targetPercentage \n                : targetPercentage - currentPercentage;\n            \n            groupDeviations[groupId] = deviation;\n            groupTokens[groupId] = group.tokens;\n            \n            if (deviation > driftPercentage) {\n                rebalanceNeeded = true;\n            }\n        }\n        \n        if (rebalanceNeeded) {\n            // Flatten tokens array for the event\n            address[] memory allTokens = new address[](assetAddresses.length);\n            uint256[] memory allDeviations = new uint256[](assetAddresses.length);\n            \n            uint256 tokenIndex = 0;\n            for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n                for (uint256 i = 0; i < groupTokens[groupId].length; i++) {\n                    allTokens[tokenIndex] = groupTokens[groupId][i];\n                    allDeviations[tokenIndex] = groupDeviations[groupId];\n                    tokenIndex++;\n                }\n            }\n            \n            emit RebalanceNeeded(allTokens, allDeviations);\n        }\n    }\n}\n"
    },
    "contracts/portfolio/balancers/OptimizedStableAggregateBalancer.sol": {
      "content": ""
    },
    "contracts/portfolio/balancers/OptimizedTimeBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../modules/OptimizedBaseBalancer.sol\";\n\ncontract OptimizedTimeBalancer is OptimizedBaseBalancer {\n    uint256 public interval;\n    uint256 public lastRebalance;\n\n    event IntervalUpdated(uint256 newInterval);\n    event RebalanceNeeded(uint256[] allocations, uint256 timestamp);\n\n    constructor(\n        address _owner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256 _interval,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol\n    ) OptimizedBaseBalancer(_owner, _factory, _assetAddresses, _percentages, _stablecoins, _limitOrderProtocol) {\n        interval = _interval;\n        lastRebalance = block.timestamp;\n    }\n\n    function triggerTimeRebalance() external {\n        require(block.timestamp >= lastRebalance + interval, \"Too early\");\n        lastRebalance = block.timestamp;\n        \n        uint256[] memory current = currentAllocations();\n        emit RebalanceNeeded(current, block.timestamp);\n    }\n\n    function setRebalanceInterval(uint256 _interval) external onlyOwner {\n        interval = _interval;\n        emit IntervalUpdated(_interval);\n    }\n\n    function currentAllocations() public view returns (uint256[] memory) {\n        uint256[] memory allocations = new uint256[](assetGroupsCount);\n        for (uint256 i = 0; i < assetGroupsCount; i++) {\n            allocations[i] = assetGroups[i].percentage;\n        }\n        return allocations;\n    }\n}\n"
    },
    "contracts/portfolio/factory/OptimizedBalancerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/*\n * OptimizedBalancerFactory\n *\n * Optimized factory contract that deploys OptimizedDriftBalancer or OptimizedTimeBalancer\n * instances with reduced contract sizes through library usage.\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../balancers/OptimizedDriftBalancer.sol\";\nimport \"../balancers/OptimizedTimeBalancer.sol\";\nimport \"../interfaces/ILimitOrderProtocol.sol\";\n\n\ncontract OptimizedBalancerFactory is Ownable {\n    address public priceFeed;\n    address[] public stablecoins;\n    ILimitOrderProtocol public limitOrderProtocol;\n\n    constructor(address _priceFeed, address[] memory _stablecoins, address _limitOrderProtocol) Ownable(msg.sender) {\n        priceFeed = _priceFeed;\n        stablecoins = _stablecoins;\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n    }\n\n    /// @dev Lists of deployed drift and time balancers per user\n    mapping(address => address[]) public userDriftBalancers;\n    mapping(address => address[]) public userTimeBalancers;\n\n    /// @dev Emitted when a new balancer is created\n    event BalancerCreated(address indexed owner, address indexed balancer, bool isTimeBased);\n\n    error NoStablecoin();\n\n    /**\n     * @notice Create a new OptimizedDriftBalancer\n     */\n    function createDriftBalancer(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256[] memory _amounts,\n        uint256 _driftPercentage\n    ) external returns (address balancer) {\n\n        // _checkUserTokenBalance(_assetAddresses, _amounts);\n\n        balancer = address(new OptimizedDriftBalancer(\n            msg.sender, \n            address(this), \n            _assetAddresses, \n            _percentages, \n            _driftPercentage, \n            stablecoins,\n            address(limitOrderProtocol)\n        ));\n\n        _sendTokensToBalancer(balancer, _assetAddresses, _amounts);\n        userDriftBalancers[msg.sender].push(balancer);\n        emit BalancerCreated(msg.sender, balancer, false);\n    }\n\n    /**\n     * @notice Create a new OptimizedTimeBalancer\n     */\n    function createTimeBalancer(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256[] memory _amounts,\n        uint256 interval\n    ) external returns (address balancer) {\n        _checkUserTokenBalance(_assetAddresses, _amounts);\n        // _requireAtLeastOneStablecoin(_assetAddresses);\n\n        balancer = address(new OptimizedTimeBalancer(\n            msg.sender, \n            address(this), \n            _assetAddresses, \n            _percentages, \n            interval, \n            stablecoins,\n            address(limitOrderProtocol)\n        ));\n\n        _sendTokensToBalancer(balancer, _assetAddresses, _amounts);\n        userTimeBalancers[msg.sender].push(balancer);\n        emit BalancerCreated(msg.sender, balancer, true);\n    }\n\n    /**\n     * @notice Internal function to send tokens to a newly created balancer\n     */\n    function _sendTokensToBalancer(address balancer, address[] memory tokens, uint256[] memory amounts) internal {\n        require(tokens.length == amounts.length, \"Tokens and amounts length mismatch\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).transferFrom(msg.sender, balancer, amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to check if the asset addresses contain at least one stablecoin\n     * @dev This function is not used in the current implementation as the stablecoins adressess will be hardcoded in the factory\n     */\n    // function _requireAtLeastOneStablecoin(address[] memory _assetAddresses) internal view {\n    //     for (uint i = 0; i < _assetAddresses.length; i++) {\n    //         for (uint j = 0; j < stablecoins.length; j++) {\n    //             if (_assetAddresses[i] == stablecoins[j]) {\n    //                 return;\n    //             }\n    //         }\n    //     }\n    //     revert NoStablecoin();\n    // }\n\n    function _checkUserTokenBalance(address[] memory tokens, uint256[] memory amounts) internal view {\n        require(tokens.length == amounts.length, \"Tokens and amounts length mismatch\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(IERC20(tokens[i]).balanceOf(msg.sender) >= amounts[i], \"Insufficient token balance in factory\");\n        }\n    }\n} "
    },
    "contracts/portfolio/interfaces/IBalancerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IBalancerFactory {\n    function priceFeed() external view returns (address);\n    function stablecoins() external view returns (address[] memory);\n}\n"
    },
    "contracts/portfolio/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param _hash      Hash of the data to be signed\n     * @param _signature Signature byte array associated with _hash\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */ \n    function isValidSignature(\n        bytes32 _hash, \n        bytes memory _signature\n    ) external view returns (bytes4 magicValue);\n} "
    },
    "contracts/portfolio/interfaces/ILimitOrderProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface ILimitOrderProtocol {\n    struct Order {\n        uint256 salt;\n        address maker;\n        address receiver;\n        address makerAsset;\n        address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        uint256 makerTraits;\n    }\n\n    struct TakerTraits {\n        uint256 traits;\n        bytes args;\n    }\n\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address indexed taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount\n    );\n\n    function fillOrderArgs(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits calldata takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits calldata takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    function cancelOrder(bytes32 orderHash, uint256 makerTraits) external;\n} "
    },
    "contracts/portfolio/interfaces/ISpotPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface ISpotPriceAggregator {\n    function getRateToEth(\n        address srcToken,\n        bool useSrcWrappers\n    ) external view returns (uint256 weightedRate);\n\n    function getRate(\n        address srcToken,\n        address dstToken,\n        bool useWrappers\n    ) external view returns (uint256 weightedRate);\n\n    function connectors() external view returns (address[] memory allConnectors);\n    function oracles() external view returns (address[] memory allOracles, uint8[] memory oracleTypes);\n    function owner() external view returns (address);\n    \n    // Additional functions from the ABI can be added here as needed\n}\n"
    },
    "contracts/portfolio/libraries/LimitOrderLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../interfaces/ILimitOrderProtocol.sol\";\n\n/**\n * @title LimitOrderLib\n * @dev Library for creating and managing 1inch limit orders\n * @author @ppezzull\n */\nlibrary LimitOrderLib {\n    // Maker traits flags\n    uint256 private constant NO_PARTIAL_FILLS_FLAG = 255;\n    uint256 private constant ALLOW_MULTIPLE_FILLS_FLAG = 254;\n    uint256 private constant NEED_PREINTERACTION_FLAG = 252;\n    uint256 private constant NEED_POSTINTERACTION_FLAG = 251;\n    uint256 private constant NEED_EPOCH_CHECK_FLAG = 250;\n    uint256 private constant HAS_EXTENSION_FLAG = 249;\n    uint256 private constant USE_PERMIT2_FLAG = 248;\n    uint256 private constant UNWRAP_WETH_FLAG = 247;\n\n    // Taker traits flags\n    uint256 private constant MAKER_AMOUNT_FLAG = 255;\n    uint256 private constant UNWRAP_WETH_FLAG_TAKER = 254;\n    uint256 private constant SKIP_ORDER_PERMIT_FLAG = 253;\n    uint256 private constant USE_PERMIT2_FLAG_TAKER = 252;\n    uint256 private constant ARGS_HAS_TARGET = 251;\n\n    struct LimitOrderData {\n        ILimitOrderProtocol.Order order;\n        bytes extension;\n        bytes signature;\n        uint256 orderHash;\n    }\n\n    struct RebalanceOrder {\n        address sellToken;\n        address buyToken;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint256 slippageTolerance; // in basis points (1 = 0.01%)\n    }\n\n    event LimitOrderCreated(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    /**\n     * @dev Create a basic limit order\n     */\n    function createLimitOrder(\n        address maker,\n        address receiver,\n        address makerAsset,\n        address takerAsset,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 salt,\n        bool allowPartialFills,\n        bool allowMultipleFills,\n        uint256 expiration\n    ) internal pure returns (ILimitOrderProtocol.Order memory order) {\n        uint256 makerTraits = buildMakerTraits(\n            address(0), // allowedSender\n            false, // shouldCheckEpoch\n            allowPartialFills, // allowPartialFill\n            allowMultipleFills, // allowMultipleFills\n            false, // usePermit2\n            false, // unwrapWeth\n            expiration, // expiry\n            0, // nonce\n            0 // series\n        );\n\n        order = ILimitOrderProtocol.Order({\n            salt: salt,\n            maker: maker,\n            receiver: receiver,\n            makerAsset: makerAsset,\n            takerAsset: takerAsset,\n            makingAmount: makingAmount,\n            takingAmount: takingAmount,\n            makerTraits: makerTraits\n        });\n    }\n\n    /**\n     * @dev Create a rebalancing limit order\n     */\n    function createRebalanceOrder(\n        RebalanceOrder memory rebalanceOrder,\n        address maker,\n        uint256 salt\n    ) external pure returns (ILimitOrderProtocol.Order memory order) {\n        order = createLimitOrder(\n            maker, // maker\n            maker, // receiver\n            rebalanceOrder.sellToken, // makerAsset\n            rebalanceOrder.buyToken, // takerAsset\n            rebalanceOrder.sellAmount, // makingAmount\n            rebalanceOrder.buyAmount, // takingAmount\n            salt, // salt\n            true, // allowPartialFills\n            false, // allowMultipleFills\n            3600 // expiration: 1 hour expiration (will be added to current timestamp)\n        );\n    }\n\n    /**\n     * @dev Build maker traits for limit orders\n     */\n    function buildMakerTraits(\n        address allowedSender,\n        bool shouldCheckEpoch,\n        bool allowPartialFill,\n        bool allowMultipleFills,\n        bool usePermit2,\n        bool unwrapWeth,\n        uint256 expiry,\n        uint256 nonce,\n        uint256 series\n    ) internal pure returns (uint256 makerTraits) {\n        // Validate inputs\n        require(expiry < (1 << 40), \"Expiry too large\");\n        require(nonce < (1 << 40), \"Nonce too large\");\n        require(series < (1 << 40), \"Series too large\");\n\n        makerTraits = (series << 160) |\n                     (nonce << 120) |\n                     (expiry << 80) |\n                     (uint256(uint160(allowedSender)) & ((1 << 80) - 1));\n\n        // Set flags\n        if (!allowPartialFill) makerTraits |= (1 << NO_PARTIAL_FILLS_FLAG);\n        if (allowMultipleFills) makerTraits |= (1 << ALLOW_MULTIPLE_FILLS_FLAG);\n        if (shouldCheckEpoch) makerTraits |= (1 << NEED_EPOCH_CHECK_FLAG);\n        if (usePermit2) makerTraits |= (1 << USE_PERMIT2_FLAG);\n        if (unwrapWeth) makerTraits |= (1 << UNWRAP_WETH_FLAG);\n    }\n\n    /**\n     * @dev Build taker traits for order filling\n     */\n    function buildTakerTraits(\n        bool makingAmount,\n        bool unwrapWeth,\n        bool skipMakerPermit,\n        bool usePermit2,\n        address target,\n        bytes memory extension,\n        bytes memory interaction,\n        uint256 threshold\n    ) internal pure returns (ILimitOrderProtocol.TakerTraits memory takerTraits) {\n        uint256 traits = threshold;\n\n        if (makingAmount) traits |= (1 << MAKER_AMOUNT_FLAG);\n        if (unwrapWeth) traits |= (1 << UNWRAP_WETH_FLAG_TAKER);\n        if (skipMakerPermit) traits |= (1 << SKIP_ORDER_PERMIT_FLAG);\n        if (usePermit2) traits |= (1 << USE_PERMIT2_FLAG_TAKER);\n        if (target != address(0)) traits |= (1 << ARGS_HAS_TARGET);\n\n        // Add extension and interaction lengths\n        traits |= (uint256(extension.length) << 224);\n        traits |= (uint256(interaction.length) << 200);\n\n        takerTraits.traits = traits;\n        takerTraits.args = abi.encodePacked(target, extension, interaction);\n    }\n\n    /**\n     * @dev Calculate order hash\n     */\n    function calculateOrderHash(\n        ILimitOrderProtocol.Order memory order,\n        bytes32 domainSeparator\n    ) external pure returns (bytes32 orderHash) {\n        orderHash = keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator,\n            keccak256(abi.encode(\n                order.salt,\n                order.maker,\n                order.receiver,\n                order.makerAsset,\n                order.takerAsset,\n                order.makingAmount,\n                order.takingAmount,\n                order.makerTraits\n            ))\n        ));\n    }\n\n    /**\n     * @dev Validate order parameters\n     */\n    function validateOrder(ILimitOrderProtocol.Order memory order) external pure returns (bool) {\n        require(order.maker != address(0), \"Invalid maker\");\n        require(order.makerAsset != address(0), \"Invalid maker asset\");\n        require(order.takerAsset != address(0), \"Invalid taker asset\");\n        require(order.makingAmount > 0, \"Invalid making amount\");\n        require(order.takingAmount > 0, \"Invalid taking amount\");\n        require(order.makerAsset != order.takerAsset, \"Same assets\");\n        \n        return true;\n    }\n\n    /**\n     * @dev Calculate slippage-adjusted amounts\n     */\n    function calculateSlippageAmounts(\n        uint256 baseAmount,\n        uint256 slippageTolerance\n    ) external pure returns (uint256 minAmount, uint256 maxAmount) {\n        require(slippageTolerance <= 1000, \"Slippage too high\"); // Max 10%\n        \n        uint256 tolerance = (baseAmount * slippageTolerance) / 10000;\n        minAmount = baseAmount - tolerance;\n        maxAmount = baseAmount + tolerance;\n    }\n} "
    },
    "contracts/portfolio/libraries/PortfolioAnalysisLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nlibrary PortfolioAnalysisLib {\n    struct PortfolioData {\n        uint256 portfolioValue;\n        uint256 stablecoinRatio;\n        bool isBalanced;\n        bool rebalanceNeeded;\n    }\n\n    struct AssetAnalysis {\n        address token;\n        uint256 balance;\n        uint256 currentPercentage;\n        uint256 targetPercentage;\n        uint256 deviation;\n        bool withinRange;\n    }\n\n    /**\n     * @dev Check if an asset's balance is within acceptable percentage range\n     */\n    function checkAssetBalance(\n        uint256 currentPercentage,\n        uint256 targetPercentage\n    ) internal pure returns (bool isWithinRange, uint256 deviation) {\n        if (currentPercentage > targetPercentage) {\n            deviation = currentPercentage - targetPercentage;\n        } else {\n            deviation = targetPercentage - currentPercentage;\n        }\n\n        isWithinRange = deviation <= 5; // 5% tolerance\n        return (isWithinRange, deviation);\n    }\n\n    /**\n     * @dev Calculate portfolio metrics\n     */\n    function calculatePortfolioMetrics(\n        uint256 totalValue,\n        uint256 stablecoinValue\n    ) internal pure returns (uint256 stablecoinRatio) {\n        if (totalValue == 0) return 0;\n        stablecoinRatio = (stablecoinValue * 10000) / totalValue; // Basis points\n    }\n}\n"
    },
    "contracts/portfolio/libraries/PortfolioCoreLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title PortfolioCoreLib\n * @dev Core portfolio management functions extracted from BaseBalancer\n * @author @ppezzull\n */\nlibrary PortfolioCoreLib {\n    using SafeERC20 for IERC20;\n\n    struct Asset {\n        uint256 percentage;\n    }\n\n    struct PortfolioState {\n        address[] assetAddresses;\n        mapping(address => Asset) assets;\n        uint256 lastUpdateTimestamp;\n    }\n\n    // Events\n    event Funded(address indexed asset, uint256 amount);\n    event Withdrawn(address indexed asset, uint256 amount);\n    event ETHWithdrawn(address indexed to, uint256 amount);\n    event AssetMappingUpdated(address[] assets, uint256[] percentages);\n\n    // Errors\n    error InvalidAssetCount();\n    error InvalidPercentagesSum();\n    error AssetNotFound(address asset);\n    error ZeroAddressNotAllowed();\n    error WithdrawalFailed();\n\n    /**\n     * @dev Update asset mapping with validation\n     */\n    function updateAssetMapping(\n        PortfolioState storage state,\n        address[] memory newAssetAddresses,\n        uint256[] memory newPercentages\n    ) external {\n        if (newAssetAddresses.length != newPercentages.length) {\n            revert InvalidAssetCount();\n        }\n\n        uint256 totalPercentage = 0;\n        for (uint256 i = 0; i < newPercentages.length; i++) {\n            totalPercentage += newPercentages[i];\n        }\n        if (totalPercentage != 100) {\n            revert InvalidPercentagesSum();\n        }\n\n        for (uint256 i = 0; i < newAssetAddresses.length; i++) {\n            if (newAssetAddresses[i] == address(0)) {\n                revert ZeroAddressNotAllowed();\n            }\n        }\n\n        // Clear old mapping\n        for (uint256 i = 0; i < state.assetAddresses.length; i++) {\n            delete state.assets[state.assetAddresses[i]];\n        }\n\n        state.assetAddresses = newAssetAddresses;\n        for (uint256 i = 0; i < state.assetAddresses.length; i++) {\n            state.assets[state.assetAddresses[i]] = Asset({ percentage: newPercentages[i] });\n        }\n\n        state.lastUpdateTimestamp = block.timestamp;\n        emit AssetMappingUpdated(newAssetAddresses, newPercentages);\n    }\n\n    /**\n     * @dev Fund portfolio with tokens\n     */\n    function fundAsset(\n        PortfolioState storage state,\n        address asset,\n        uint256 amount,\n        address from\n    ) external {\n        if (state.assets[asset].percentage == 0) {\n            revert AssetNotFound(asset);\n        }\n        IERC20(asset).safeTransferFrom(from, address(this), amount);\n        emit Funded(asset, amount);\n    }\n\n    /**\n     * @dev Withdraw tokens from portfolio\n     */\n    function withdrawAsset(\n        PortfolioState storage state,\n        address asset,\n        uint256 amount,\n        address to\n    ) external {\n        if (state.assets[asset].percentage == 0) {\n            revert AssetNotFound(asset);\n        }\n        IERC20(asset).safeTransfer(to, amount);\n        emit Withdrawn(asset, amount);\n    }\n\n    /**\n     * @dev Withdraw ETH from portfolio\n     */\n    function withdrawETH(address to, uint256 amount) external {\n        (bool success, ) = to.call{ value: amount }(\"\");\n        if (!success) {\n            revert WithdrawalFailed();\n        }\n        emit ETHWithdrawn(to, amount);\n    }\n\n    /**\n     * @dev Get total portfolio value\n     */\n    function getTotalValue(\n        PortfolioState storage state,\n        function(address, uint256) internal view returns (uint256) getPriceFunc\n    ) internal view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < state.assetAddresses.length; i++) {\n            address asset = state.assetAddresses[i];\n            uint256 balance = IERC20(asset).balanceOf(address(this));\n            totalValue += getPriceFunc(asset, balance);\n        }\n        return totalValue;\n    }\n\n    /**\n     * @dev Get asset addresses\n     */\n    function getAssetAddresses(PortfolioState storage state) external view returns (address[] memory) {\n        return state.assetAddresses;\n    }\n\n    /**\n     * @dev Get asset details\n     */\n    function getAsset(PortfolioState storage state, address asset) external view returns (Asset memory) {\n        return state.assets[asset];\n    }\n\n    /**\n     * @dev Get asset balance\n     */\n    function getAssetBalance(address asset) external view returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Get ETH balance\n     */\n    function getETHBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n} "
    },
    "contracts/portfolio/libraries/RebalanceAnalysisLib.sol": {
      "content": ""
    },
    "contracts/portfolio/libraries/StablecoinAnalysisLib.sol": {
      "content": ""
    },
    "contracts/portfolio/libraries/StablecoinGridLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title StablecoinGridLib\n * @dev Grid trading logic for stablecoins extracted from StableLimit\n * @author @ppezzull\n */\nlibrary StablecoinGridLib {\n    struct Order {\n        address fromToken;\n        address toToken;\n        uint256 amount;\n        uint256 limitPrice; // Price with 1e18 precision\n    }\n\n    struct GridParams {\n        uint256 capital;\n        uint256 nLevels;\n        uint256 minOrderSize;\n        uint256 maxOrderSize;\n        uint256 gridRangeBps;\n        uint256 pegPrice;\n    }\n\n    // Constants\n    uint256 private constant PRICE_PRECISION = 1e18;\n    uint256 private constant USDC_DECIMALS = 6;\n    uint256 private constant DAI_DECIMALS = 18;\n\n    // Price deviation bounds (1e18 representation)\n    uint256 public constant LOWER_BOUND = 998 * 1e15; // 0.998\n    uint256 public constant UPPER_BOUND = 1002 * 1e15; // 1.002\n\n    /**\n     * @dev Generate grid orders for stablecoin pairs\n     */\n    function generateGridOrders(\n        address[] memory stablecoins,\n        GridParams memory params\n    ) external pure returns (Order[] memory orders) {\n        if (params.nLevels == 0) return new Order[](0);\n\n        uint256 nPairs = stablecoins.length > 1 ? stablecoins.length : 0;\n        if (nPairs < 2) return new Order[](0);\n\n        uint256 nLevelsAdjusted = params.nLevels;\n        uint256 baseOrderAmount = params.capital / (params.nLevels * 2 * (nPairs - 1));\n\n        if (baseOrderAmount < params.minOrderSize) {\n            nLevelsAdjusted = params.capital / (params.minOrderSize * 2 * (nPairs - 1));\n            if (nLevelsAdjusted == 0) nLevelsAdjusted = 1;\n        } else if (baseOrderAmount > params.maxOrderSize) {\n            nLevelsAdjusted = params.capital / (params.maxOrderSize * 2 * (nPairs - 1));\n            uint256 maxLevels = 100;\n            if (nLevelsAdjusted > maxLevels) nLevelsAdjusted = maxLevels;\n        }\n\n        if (nLevelsAdjusted == 0) return new Order[](0);\n\n        uint256 finalOrderAmount = params.capital / (nLevelsAdjusted * 2 * (nPairs - 1));\n        orders = new Order[](nLevelsAdjusted * 2 * (nPairs - 1));\n        uint256 idx = 0;\n\n        for (uint256 pair = 0; pair < nPairs - 1; pair++) {\n            address fromToken = stablecoins[pair];\n            address toToken = stablecoins[(pair + 1) % nPairs];\n            for (uint256 i = 0; i < nLevelsAdjusted; i++) {\n                uint256 offset = ((((i + 1) * PRICE_PRECISION) / nLevelsAdjusted) * params.gridRangeBps) / 10000;\n                orders[idx++] = Order(fromToken, toToken, finalOrderAmount, params.pegPrice + offset);\n                orders[idx++] = Order(toToken, fromToken, finalOrderAmount, params.pegPrice - offset);\n            }\n        }\n\n        return orders;\n    }\n\n    /**\n     * @dev Check if price is within acceptable bounds\n     */\n    function isPriceWithinBounds(uint256 price) external pure returns (bool) {\n        return price >= LOWER_BOUND && price <= UPPER_BOUND;\n    }\n\n    /**\n     * @dev Calculate grid order parameters\n     */\n    function calculateGridParams(\n        uint256 stablecoinValue,\n        uint256 nLevels,\n        uint256 gridRangeBps\n    ) external pure returns (GridParams memory params) {\n        params.capital = stablecoinValue / 10; // Use 10% of stablecoin value\n        params.nLevels = nLevels;\n        params.minOrderSize = 10 * (10 ** USDC_DECIMALS); // 10 USDC\n        params.maxOrderSize = params.capital;\n        params.gridRangeBps = gridRangeBps;\n        params.pegPrice = 1 * PRICE_PRECISION; // 1 USD for stablecoins\n    }\n\n    /**\n     * @dev Validate stablecoin pair for grid trading\n     */\n    function validateStablecoinPair(\n        address token1,\n        address token2,\n        mapping(address => bool) storage isStablecoin\n    ) external view returns (bool) {\n        return isStablecoin[token1] && isStablecoin[token2] && token1 != token2;\n    }\n} "
    },
    "contracts/portfolio/libraries/TradingExecutionLib.sol": {
      "content": ""
    },
    "contracts/portfolio/modules/OptimizedBaseBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../interfaces/ISpotPriceAggregator.sol\";\nimport \"../interfaces/IBalancerFactory.sol\";\nimport \"../libraries/PortfolioAnalysisLib.sol\";\nimport \"./OptimizedStableLimit.sol\";\n\n/**\n * @title OptimizedBaseBalancer\n * @notice Optimized version of BaseBalancer with reduced contract size\n */\nabstract contract OptimizedBaseBalancer is Ownable, ReentrancyGuard, OptimizedStableLimit {\n    using SafeERC20 for IERC20;\n    using PortfolioAnalysisLib for uint256;\n\n    // -- Constants --\n    uint256 public constant MAX_BASIS_POINTS = 100;\n\n    // -- State --\n    struct AssetGroup {\n        uint256 percentage;\n        address[] tokens; // For stablecoins, this will contain multiple tokens\n        bool isStablecoinGroup;\n    }\n\n    mapping(uint256 => AssetGroup) public assetGroups;\n    uint256 public assetGroupsCount;\n    address[] public assetAddresses; // All tokens (including stablecoins)\n    uint256 public lastUpdateTimestamp;\n\n    // -- Events --\n    event Funded(address indexed asset, uint256 amount);\n    event Withdrawn(address indexed asset, uint256 amount);\n    event AssetMappingUpdated(address[] assets, uint256[] percentages);\n\n    // -- Errors --\n    error InvalidAssetCount();\n    error InvalidPercentagesSum();\n    error AssetGroupNotFound(uint256 groupId);\n    error ZeroAddressNotAllowed();\n\n    constructor(\n        address initialOwner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol\n    ) Ownable(initialOwner) OptimizedStableLimit(initialOwner, _factory, _stablecoins, _limitOrderProtocol) {\n        _updateAssetGroupMapping(_assetAddresses, _percentages, _stablecoins);\n        lastUpdateTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Fund the contract with a specific ERC20 token\n     */\n    function fund(address _asset, uint256 _amount) external onlyOwner {\n        require(_isValidAsset(_asset), \"Asset not found in any group\");\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Funded(_asset, _amount);\n    }\n\n    /**\n     * @notice Withdraw a specific ERC20 token from the contract\n     */\n    function withdraw(address _asset, uint256 _amount) external onlyOwner nonReentrant {\n        require(_isValidAsset(_asset), \"Asset not found in any group\");\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n        emit Withdrawn(_asset, _amount);\n    }\n\n    /**\n     * @notice Update the asset mapping\n     */\n    function updateAssetMapping(\n        address[] memory _assetAddresses, \n        uint256[] memory _percentages,\n        address[] memory _stablecoins\n    ) external onlyOwner {\n        _updateAssetGroupMapping(_assetAddresses, _percentages, _stablecoins);\n    }\n\n    /**\n     * @notice Get total portfolio value in ETH\n     */\n    function getTotalValue() public view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < assetAddresses.length; i++) {\n            address asset = assetAddresses[i];\n            uint256 balance = IERC20(asset).balanceOf(address(this));\n            totalValue += getPrice(asset, balance);\n        }\n        return totalValue;\n    }\n\n    /**\n     * @notice Get price of an asset in ETH\n     */\n    function getPrice(address asset, uint256 amount) public view returns (uint256) {\n        address priceFeedAddr = IBalancerFactory(factory).priceFeed();\n        uint256 price = ISpotPriceAggregator(priceFeedAddr).getRateToEth(asset, false);\n        return (amount * price) / 1e18;\n    }\n\n    /**\n     * @notice Check asset balance using library\n     */\n    function checkAssetBalance(\n        address,\n        uint256,\n        uint256 currentPercentage,\n        uint256 targetPercentage,\n        uint256\n    ) public pure override returns (bool isWithinRange, uint256 deviation) {\n        return PortfolioAnalysisLib.checkAssetBalance(currentPercentage, targetPercentage);\n    }\n\n    /**\n     * @notice Get basic portfolio analysis\n     */\n    function getPortfolioAnalysis() external view returns (\n        uint256 portfolioValue,\n        uint256 stablecoinRatio,\n        bool isBalanced\n    ) {\n        portfolioValue = getTotalValue();\n        if (portfolioValue == 0) return (0, 0, true);\n\n        uint256 totalStablecoinValue = _getTotalStablecoinValue();\n        stablecoinRatio = PortfolioAnalysisLib.calculatePortfolioMetrics(portfolioValue, totalStablecoinValue);\n        \n        isBalanced = _checkIfBalanced(portfolioValue);\n    }\n\n    // -- Internal Functions --\n    function _updateAssetGroupMapping(\n        address[] memory _assetAddresses, \n        uint256[] memory _percentages,\n        address[] memory _stablecoins\n    ) internal {\n        require(_percentages.length > 0, \"No percentages provided\");\n        require(_assetAddresses.length > 0, \"No assets provided\");\n        \n        // Count non-stablecoin assets\n        uint256 nonStablecoinCount = 0;\n        uint256 stablecoinCount = 0;\n        \n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            bool isStablecoin = false;\n            for (uint256 j = 0; j < _stablecoins.length; j++) {\n                if (_assetAddresses[i] == _stablecoins[j]) {\n                    isStablecoin = true;\n                    stablecoinCount++;\n                    break;\n                }\n            }\n            if (!isStablecoin) {\n                nonStablecoinCount++;\n            }\n        }\n        \n        // Calculate expected percentage count: 1 for stablecoins (if any) + 1 for each non-stablecoin\n        uint256 expectedPercentageCount = (stablecoinCount > 0 ? 1 : 0) + nonStablecoinCount;\n        \n        require(_percentages.length == expectedPercentageCount, \"Wrong percentage count for asset groups\");\n        \n        uint256 totalPercentage = 0;\n        for (uint256 i = 0; i < _percentages.length; i++) {\n            totalPercentage += _percentages[i];\n        }\n        if (totalPercentage != MAX_BASIS_POINTS) revert InvalidPercentagesSum();\n\n        // Clear old mappings\n        for (uint256 i = 0; i < assetGroupsCount; i++) {\n            delete assetGroups[i];\n        }\n        \n        assetAddresses = _assetAddresses;\n        assetGroupsCount = 0;\n\n        // Create stablecoin group if we have stablecoins in the asset list\n        if (stablecoinCount > 0) {\n            address[] memory stablecoinAssets = new address[](stablecoinCount);\n            uint256 stablecoinIndex = 0;\n            \n            for (uint256 i = 0; i < _assetAddresses.length; i++) {\n                for (uint256 j = 0; j < _stablecoins.length; j++) {\n                    if (_assetAddresses[i] == _stablecoins[j]) {\n                        stablecoinAssets[stablecoinIndex] = _assetAddresses[i];\n                        stablecoinIndex++;\n                        break;\n                    }\n                }\n            }\n            \n            assetGroups[assetGroupsCount] = AssetGroup({\n                percentage: _percentages[0], // First percentage is for stablecoins\n                tokens: stablecoinAssets,\n                isStablecoinGroup: true\n            });\n            assetGroupsCount++;\n        }\n        \n        // Create groups for non-stablecoin assets\n        uint256 percentageIndex = stablecoinCount > 0 ? 1 : 0;\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            bool isStablecoin = false;\n            for (uint256 j = 0; j < _stablecoins.length; j++) {\n                if (_assetAddresses[i] == _stablecoins[j]) {\n                    isStablecoin = true;\n                    break;\n                }\n            }\n            \n            if (!isStablecoin) {\n                address[] memory singleAsset = new address[](1);\n                singleAsset[0] = _assetAddresses[i];\n                \n                assetGroups[assetGroupsCount] = AssetGroup({\n                    percentage: _percentages[percentageIndex],\n                    tokens: singleAsset,\n                    isStablecoinGroup: false\n                });\n                assetGroupsCount++;\n                percentageIndex++;\n            }\n        }\n\n        emit AssetMappingUpdated(_assetAddresses, _percentages);\n    }\n    \n    function _isValidAsset(address _asset) internal view returns (bool) {\n        for (uint256 i = 0; i < assetAddresses.length; i++) {\n            if (assetAddresses[i] == _asset) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _checkIfBalanced(uint256 portfolioValue) internal view returns (bool) {\n        for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n            AssetGroup memory group = assetGroups[groupId];\n            uint256 groupValue = 0;\n            \n            // Calculate total value for this group\n            for (uint256 i = 0; i < group.tokens.length; i++) {\n                uint256 balance = IERC20(group.tokens[i]).balanceOf(address(this));\n                groupValue += getPrice(group.tokens[i], balance);\n            }\n            \n            uint256 currentPercentage = (groupValue * 100) / portfolioValue;\n            uint256 targetPercentage = group.percentage;\n            \n            (bool withinRange, ) = PortfolioAnalysisLib.checkAssetBalance(currentPercentage, targetPercentage);\n            if (!withinRange) return false;\n        }\n        return true;\n    }\n\n    // -- View Functions --\n    function getAssetAddresses() external view returns (address[] memory) {\n        return assetAddresses;\n    }\n\n    function getAssetGroup(uint256 groupId) external view returns (AssetGroup memory) {\n        return assetGroups[groupId];\n    }\n\n    function getAssetBalance(address _asset) external view returns (uint256) {\n        return IERC20(_asset).balanceOf(address(this));\n    }\n    \n    function getStablecoinGroupValue() external view returns (uint256) {\n        for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n            if (assetGroups[groupId].isStablecoinGroup) {\n                uint256 groupValue = 0;\n                for (uint256 i = 0; i < assetGroups[groupId].tokens.length; i++) {\n                    uint256 balance = IERC20(assetGroups[groupId].tokens[i]).balanceOf(address(this));\n                    groupValue += getPrice(assetGroups[groupId].tokens[i], balance);\n                }\n                return groupValue;\n            }\n        }\n        return 0;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/portfolio/modules/OptimizedStableLimit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/ISpotPriceAggregator.sol\";\nimport \"../interfaces/IBalancerFactory.sol\";\nimport \"../interfaces/ILimitOrderProtocol.sol\";\nimport \"../interfaces/IERC1271.sol\";\nimport \"../libraries/StablecoinGridLib.sol\";\nimport \"../libraries/LimitOrderLib.sol\";\n\n/// @title OptimizedStableLimit\n/// @notice Optimized stablecoin grid trading with reduced contract size\n/// @dev Implements Chainlink Automation to trigger rebalancing when stablecoin prices deviate\n/// Implements EIP-1271 for limit order signing\nabstract contract OptimizedStableLimit is Ownable, Pausable, AutomationCompatibleInterface, IERC1271 {\n    using SafeERC20 for IERC20;\n    using StablecoinGridLib for *;\n    using LimitOrderLib for *;\n    using ECDSA for bytes32;\n\n    // -- State --\n    IBalancerFactory public factory;\n    address[] public stablecoins;\n    mapping(address => bool) public isStablecoin;\n    \n    // Limit order protocol integration\n    ILimitOrderProtocol public limitOrderProtocol;\n    bytes32 public domainSeparator;\n    uint256 private nonce;\n    \n    // EIP-1271 magic value\n    bytes4 private constant MAGIC_VALUE = 0x1626ba7e;\n\n    // -- Events --\n    event LimitOrderPlaced(StablecoinGridLib.Order order);\n    event OrdersGenerated(StablecoinGridLib.Order[] orders);\n    event StablecoinsUpdated(address[] newStablecoins);\n    event LimitOrderCreated(bytes32 indexed orderHash, address indexed maker, address sellToken, address buyToken, uint256 sellAmount, uint256 buyAmount);\n    event RebalanceOrderCreated(bytes32 indexed orderHash, address indexed maker, address sellToken, address buyToken, uint256 sellAmount, uint256 buyAmount, uint256 slippageTolerance);\n\n    // Modifiers\n    modifier onlyFactoryOrOwner() {\n        require(msg.sender == address(factory) || msg.sender == owner(), \"StableLimit__Unauthorized\");\n        _;\n    }\n\n    constructor(address initialOwner, address _factory, address[] memory _stablecoins, address _limitOrderProtocol) {\n        _transferOwnership(initialOwner);\n        _pause(); // Start paused\n        _unpause(); // Then unpause\n        factory = IBalancerFactory(_factory);\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n        \n        for (uint i = 0; i < _stablecoins.length; i++) {\n            stablecoins.push(_stablecoins[i]);\n            isStablecoin[_stablecoins[i]] = true;\n        }\n        \n        // Initialize domain separator for EIP-712\n        domainSeparator = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(\"1inch Limit Order Protocol\")),\n            keccak256(bytes(\"4\")),\n            block.chainid,\n            _limitOrderProtocol\n        ));\n    }\n\n    /**\n     * @dev Check if an asset's balance is within acceptable percentage range based on price\n     */\n    function checkAssetBalance(\n        address /* token */,\n        uint256 /* currentBalance */,\n        uint256 currentPercentage,\n        uint256 targetPercentage,\n        uint256 /* price */\n    ) virtual public pure returns (bool isWithinRange, uint256 deviation) {\n        if (currentPercentage > targetPercentage) {\n            deviation = currentPercentage - targetPercentage;\n        } else {\n            deviation = targetPercentage - currentPercentage;\n        }\n\n        isWithinRange = deviation <= 5;\n        return (isWithinRange, deviation);\n    }\n\n    // -- Automation Functions --\n\n    function checkUpkeep(\n        bytes calldata /* checkData */\n    ) external view override returns (bool upkeepNeeded, bytes memory performData) {\n        // Check all stablecoin pairs for deviation\n        for (uint i = 0; i < stablecoins.length; i++) {\n            for (uint j = i + 1; j < stablecoins.length; j++) {\n                uint256 currentPrice = ISpotPriceAggregator(factory.priceFeed()).getRate(stablecoins[i], stablecoins[j], false);\n                if (!StablecoinGridLib.isPriceWithinBounds(currentPrice)) {\n                    return (true, abi.encode(stablecoins[i], stablecoins[j], currentPrice));\n                }\n            }\n        }\n        return (false, bytes(\"\"));\n    }\n\n    function performUpkeep(bytes calldata /*performData*/) external override whenNotPaused {\n        // // Decode the performData to get the token pair and price\n        // (address token1, address token2, uint256 currentPrice) = abi.decode(performData, (address, address, uint256));\n\n        // Get the total value of stablecoins in the contract\n        uint256 stablecoinValue = _getTotalStablecoinValue();\n\n        // Calculate grid parameters\n        StablecoinGridLib.GridParams memory params = StablecoinGridLib.calculateGridParams(\n            stablecoinValue,\n            5, // n_levels\n            15 // grid_range_bps (0.0015 * 10000 = 15)\n        );\n\n        // Generate grid orders\n        StablecoinGridLib.Order[] memory orders = StablecoinGridLib.generateGridOrders(stablecoins, params);\n\n        emit OrdersGenerated(orders);\n\n        // Create actual limit orders for stablecoin pairs\n        for (uint i = 0; i < orders.length; i++) {\n            StablecoinGridLib.Order memory gridOrder = orders[i];\n            \n            // Create limit order for this grid level\n            bytes32 orderHash = createStablecoinGridOrder(\n                gridOrder.fromToken,\n                gridOrder.toToken,\n                gridOrder.amount,\n                gridOrder.limitPrice\n            );\n            \n            // Emit event for order submission\n            emit LimitOrderCreated(\n                orderHash,\n                address(this),\n                gridOrder.fromToken,\n                gridOrder.toToken,\n                gridOrder.amount,\n                gridOrder.limitPrice\n            );\n        }\n    }\n\n    // -- Internal Logic --\n\n    function _placeLimitOrder(StablecoinGridLib.Order memory order) internal {\n        // Mocked: Emits event instead of executing trade\n        emit LimitOrderPlaced(order);\n    }\n\n    function _getTotalStablecoinValue() internal view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            address stablecoin = stablecoins[i];\n            uint256 balance = IERC20(stablecoin).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 price = ISpotPriceAggregator(factory.priceFeed()).getRateToEth(stablecoin, false);\n                totalValue += (balance * price) / 1e18;\n            }\n        }\n        return totalValue;\n    }\n\n    function updateStablecoins(address[] memory _stablecoins) external onlyOwner {\n        stablecoins = _stablecoins;\n        emit StablecoinsUpdated(_stablecoins);\n    }\n\n    // -- EIP-1271 Implementation --\n\n    /**\n     * @dev EIP-1271 signature validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view override returns (bytes4 magicValue) {\n        // For now, only the owner can sign orders\n        // In a real implementation, you might want more sophisticated signature validation\n        address signer = _hash.recover(_signature);\n        if (signer == owner()) {\n            return MAGIC_VALUE;\n        }\n        return 0xffffffff;\n    }\n\n    // -- Limit Order Functions --\n\n    /**\n     * @dev Create a rebalancing limit order\n     */\n    function createRebalanceOrder(\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 slippageTolerance\n    ) external onlyOwner returns (bytes32 orderHash) {\n        LimitOrderLib.RebalanceOrder memory rebalanceOrder = LimitOrderLib.RebalanceOrder({\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellAmount: sellAmount,\n            buyAmount: buyAmount,\n            slippageTolerance: slippageTolerance\n        });\n\n        ILimitOrderProtocol.Order memory order = LimitOrderLib.createRebalanceOrder(\n            rebalanceOrder,\n            address(this),\n            nonce++\n        );\n\n        orderHash = LimitOrderLib.calculateOrderHash(order, domainSeparator);\n\n        emit RebalanceOrderCreated(\n            orderHash,\n            address(this),\n            sellToken,\n            buyToken,\n            sellAmount,\n            buyAmount,\n            slippageTolerance\n        );\n    }\n\n    /**\n     * @dev Create a stablecoin grid limit order\n     */\n    function createStablecoinGridOrder(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        uint256 limitPrice\n    ) public onlyOwner returns (bytes32 orderHash) {\n        ILimitOrderProtocol.Order memory order = LimitOrderLib.createLimitOrder({\n            maker: address(this),\n            receiver: address(this),\n            makerAsset: fromToken,\n            takerAsset: toToken,\n            makingAmount: amount,\n            takingAmount: (amount * limitPrice) / 1e18,\n            salt: nonce++,\n            allowPartialFills: true,\n            allowMultipleFills: false,\n            expiration: block.timestamp + 3600 // 1 hour\n        });\n\n        orderHash = LimitOrderLib.calculateOrderHash(order, domainSeparator);\n\n        emit LimitOrderCreated(\n            orderHash,\n            address(this),\n            fromToken,\n            toToken,\n            amount,\n            (amount * limitPrice) / 1e18\n        );\n    }\n\n    /**\n     * @dev Get order signature for submission to 1inch API\n     */\n    function getOrderSignature(bytes32 /*orderHash*/) external view onlyOwner returns (bytes memory signature) {\n        // Create a signature that can be validated by EIP-1271\n        // This is a simplified implementation - in production you'd want more sophisticated signing\n        signature = abi.encodePacked(\n            bytes32(0), // r\n            bytes32(0), // s\n            uint8(27)   // v\n        );\n    }\n\n    /**\n     * @dev Update limit order protocol address\n     */\n    function updateLimitOrderProtocol(address _limitOrderProtocol) external onlyOwner {\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n    }\n\n    // -- Pausable Functions --\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n} "
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Useful for debugging. Remove when deploying to a live network.\nimport \"hardhat/console.sol\";\n\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * A smart contract that allows changing a state variable of the contract and tracking the changes\n * It also allows the owner to withdraw the Ether in the contract\n * @author BuidlGuidl\n */\ncontract YourContract {\n    // State Variables\n    address public immutable owner;\n    string public greeting = \"Building Unstoppable Apps!!!\";\n    bool public premium = false;\n    uint256 public totalCounter = 0;\n    mapping(address => uint) public userGreetingCounter;\n\n    // Events: a way to emit log statements from smart contract that can be listened to by external parties\n    event GreetingChange(address indexed greetingSetter, string newGreeting, bool premium, uint256 value);\n\n    // Constructor: Called once on contract deployment\n    // Check packages/hardhat/deploy/00_deploy_your_contract.ts\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    // Check the withdraw() function\n    modifier isOwner() {\n        // msg.sender: predefined variable that represents address of the account that called the current function\n        require(msg.sender == owner, \"Not the Owner\");\n        _;\n    }\n\n    /**\n     * Function that allows anyone to change the state variable \"greeting\" of the contract and increase the counters\n     *\n     * @param _newGreeting (string memory) - new greeting to save on the contract\n     */\n    function setGreeting(string memory _newGreeting) public payable {\n        // Print data to the hardhat chain console. Remove when deploying to a live network.\n        console.log(\"Setting new greeting '%s' from %s\", _newGreeting, msg.sender);\n\n        // Change state variables\n        greeting = _newGreeting;\n        totalCounter += 1;\n        userGreetingCounter[msg.sender] += 1;\n\n        // msg.value: built-in global variable that represents the amount of ether sent with the transaction\n        if (msg.value > 0) {\n            premium = true;\n        } else {\n            premium = false;\n        }\n\n        // emit: keyword used to trigger an event\n        emit GreetingChange(msg.sender, _newGreeting, msg.value > 0, msg.value);\n    }\n\n    /**\n     * Function that allows the owner to withdraw all the Ether in the contract\n     * The function can only be called by the owner of the contract as defined by the isOwner modifier\n     */\n    function withdraw() public isOwner {\n        (bool success, ) = owner.call{ value: address(this).balance }(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    /**\n     * Function that allows the contract to receive ETH\n     */\n    receive() external payable {}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}