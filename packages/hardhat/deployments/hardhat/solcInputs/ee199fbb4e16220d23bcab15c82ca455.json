{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/portfolio/automation/DriftBalancerLogger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// [Chainlink] Log Trigger Upkeeps + ILogAutomation:\n/// https://docs.chain.link/chainlink-automation/guides/log-trigger\n\ninterface ILogAutomation {\n    struct Log {\n        uint256 index;\n        uint256 timestamp;\n        bytes32 txHash;\n        uint256 blockNumber;\n        bytes32 blockHash;\n        address source;\n        bytes32[] topics;\n        bytes data;\n    }\n\n    function checkLog(Log calldata log, bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n    function performUpkeep(bytes calldata performData) external;\n}\n\nimport { IDiaPushOracleReceiver } from \"../interfaces/IDiaPushOracleReceiver.sol\";\n\ninterface IDriftRebalance {\n    function triggerRebalance() external;\n    function getStablecoins() external view returns (address[] memory);\n    function getAssetAddresses() external view returns (address[] memory);\n}\n\n/// [DIA] Oracle V2 classic event (ABI ref):\n/// event OracleUpdate(string key, uint128 value, uint128 timestamp)\n/// Confirm Push Receiver’s actual event signature on Basescan and update topic0 if needed.\ncontract DriftBalancerLogger is ILogAutomation {\n    address public immutable oracle; // DIA PushOracleReceiver\n    address public immutable targetBalancer; // DriftBalancer to invoke\n    // Thresholds per key (bps). keys hashed to bytes32 to keep storage cheap\n    mapping(bytes32 => uint256) public driftThresholdBps; // keccak256(key) => threshold\n\n    event DriftRebalanced(string key, uint128 value, uint128 ts);\n\n    constructor(address _oracle, address _targetBalancer, string[] memory keys, uint256[] memory thresholdsBps) {\n        require(_oracle != address(0), \"oracle=0\");\n        require(_targetBalancer != address(0), \"target=0\");\n        require(keys.length == thresholdsBps.length, \"len mismatch\");\n        oracle = _oracle;\n        targetBalancer = _targetBalancer;\n        for (uint256 i = 0; i < keys.length; i++) {\n            driftThresholdBps[keccak256(bytes(keys[i]))] = thresholdsBps[i];\n        }\n    }\n\n    // topic0 must match the registered filter. For DIA classic:\n    // bytes32(keccak256(\"OracleUpdate(string,uint128,uint128)\"))\n    // If Push Receiver differs, compute new topic0 off-chain and use that in registration.\n    function checkLog(Log calldata log, bytes calldata) external returns (bool upkeepNeeded, bytes memory performData) {\n        // Parse DIA payload\n        (string memory key, uint128 value, uint128 ts) = abi.decode(log.data, (string, uint128, uint128));\n        // Optionally scope by key thresholds\n        uint256 thr = driftThresholdBps[keccak256(bytes(key))];\n        if (thr == 0) {\n            // If not configured, still allow upkeep to let target balancer decide\n            performData = abi.encode(key, value, ts);\n            return (true, performData);\n        }\n        // Lightweight precheck: only stablecoin keys trigger immediately\n        // Full portfolio checks happen in performUpkeep via targetBalancer.triggerRebalance()\n        performData = abi.encode(key, value, ts);\n        return (true, performData);\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        (string memory key, uint128 value, uint128 ts) = abi.decode(performData, (string, uint128, uint128));\n        // Optional: read latest on-chain pushed value to confirm\n        // (uint128 lastTs, uint128 lastVal) = IDiaPushOracleReceiver(oracle).updates(key);\n\n        // Forward to portfolio DriftBalancer to apply library-based analysis and emit orders/events\n        // This connects Automation Log trigger with existing portfolio logic.\n        try IDriftRebalance(targetBalancer).triggerRebalance() {\n            // no-op\n        } catch {}\n\n        emit DriftRebalanced(key, value, ts);\n    }\n}\n\n"
    },
    "contracts/portfolio/balancers/BaseBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\n\nimport \"../interfaces/IBalancerFactory.sol\";\nimport \"../interfaces/IOracleAdapter.sol\";\nimport \"../interfaces/IERC1271.sol\";\nimport \"../interfaces/ILimitOrderProtocol.sol\";\nimport \"../libraries/LimitOrderLib.sol\";\nimport \"../libraries/PortfolioAnalysisLib.sol\";\n\nabstract contract BaseBalancer is Ownable, Pausable, ReentrancyGuard, IERC1271, AutomationCompatibleInterface {\n    using ECDSA for bytes32;\n    using SafeERC20 for IERC20;\n    struct AssetGroup {\n        uint256 percentage;\n        address[] tokens;\n        bool isStablecoinGroup;\n    }\n\n    mapping(uint256 => AssetGroup) public assetGroups;\n    uint256 public assetGroupsCount;\n    address[] public assetAddresses;\n    uint256 public lastUpdateTimestamp;\n\n    IBalancerFactory public factory;\n    address[] public stablecoins;\n    mapping(address => bool) public isStablecoin;\n    \n    // Signature auth and automation forwarder\n    address public authorizedSigner;\n    address public s_forwarderAddress;\n    \n    // Orders / protocol\n    ILimitOrderProtocol public limitOrderProtocol;\n    bytes32 public domainSeparator;\n    uint256 internal nonce;\n    \n    // Metadata\n    string public name;\n    string public description;\n\n    event StablecoinsUpdated(address[] newStablecoins);\n    event ForwarderUpdated(address forwarder);\n    \n\n    constructor(\n        address _owner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol,\n        string memory _name,\n        string memory _description\n    ) Ownable(_owner) {\n        factory = IBalancerFactory(_factory);\n\n        for (uint256 i = 0; i < _stablecoins.length; i++) {\n            stablecoins.push(_stablecoins[i]);\n            isStablecoin[_stablecoins[i]] = true;\n        }\n\n        _updateAssetGroupMapping(_assetAddresses, _percentages, _stablecoins);\n        lastUpdateTimestamp = block.timestamp;\n\n        authorizedSigner = _owner;\n        // Default forwarder to owner to enable local testing and safe manual calls\n        s_forwarderAddress = _owner;\n        name = _name;\n        description = _description;\n\n        // Limit order protocol and domain separator\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(\"1inch Limit Order Protocol\")),\n                keccak256(bytes(\"4\")),\n                block.chainid,\n                _limitOrderProtocol\n            )\n        );\n    }\n\n    function updateStablecoins(address[] memory _stablecoins) external onlyOwner {\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            isStablecoin[stablecoins[i]] = false;\n        }\n        delete stablecoins;\n        for (uint256 i2 = 0; i2 < _stablecoins.length; i2++) {\n            stablecoins.push(_stablecoins[i2]);\n            isStablecoin[_stablecoins[i2]] = true;\n        }\n        emit StablecoinsUpdated(_stablecoins);\n    }\n\n    function updateAssetMapping(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        address[] memory _stablecoins\n    ) external onlyOwner {\n        _updateAssetGroupMapping(_assetAddresses, _percentages, _stablecoins);\n    }\n\n    \n\n    // ===== Authorization controls =====\n    function updateAuthorizedSigner(address newSigner) external onlyOwner {\n        authorizedSigner = newSigner;\n    }\n\n    function updateMetadata(string calldata _name, string calldata _description) external onlyOwner {\n        name = _name;\n        description = _description;\n    }\n\n    function pause() external onlyOwner { _pause(); }\n    function unpause() external onlyOwner { _unpause(); }\n\n    // ===== Automation-compatible API (common gating) =====\n    function checkUpkeep(bytes calldata checkData) external view virtual override returns (bool upkeepNeeded, bytes memory performData) {\n        return _checkUpkeep(checkData);\n    }\n\n    function performUpkeep(bytes calldata performData) external virtual override whenNotPaused {\n        require(msg.sender == s_forwarderAddress, \"Not authorized forwarder\");\n        _performUpkeep(performData);\n    }\n\n    function setForwarderAddress(address forwarder) external onlyOwner {\n        s_forwarderAddress = forwarder;\n        emit ForwarderUpdated(forwarder);\n    }\n\n    // Strategy hooks to implement per balancer\n    function _checkUpkeep(bytes calldata checkData) internal view virtual returns (bool, bytes memory);\n    function _performUpkeep(bytes calldata performData) internal virtual;\n\n    // ===== Funding =====\n    function fund(address _asset, uint256 _amount) external onlyOwner {\n        require(_isValidAsset(_asset), \"Asset not found in any group\");\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n    function withdraw(address _asset, uint256 _amount) external onlyOwner nonReentrant {\n        require(_isValidAsset(_asset), \"Asset not found in any group\");\n        IERC20(_asset).safeTransfer(msg.sender, _amount);\n    }\n\n    function getTotalValue() public view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < assetAddresses.length; i++) {\n            address asset = assetAddresses[i];\n            uint256 balance = IERC20(asset).balanceOf(address(this));\n            totalValue += getPrice(asset, balance);\n        }\n        return totalValue;\n    }\n\n    function getPrice(address asset, uint256 amount) public view returns (uint256) {\n        address priceFeedAddr = factory.priceFeed();\n        uint256 price = IOracleAdapter(priceFeedAddr).getRateToEth(asset, false);\n        return (amount * price) / 1e18;\n    }\n\n    function getPortfolioAnalysis() external view returns (uint256 portfolioValue, uint256 stablecoinRatio, bool isBalanced) {\n        portfolioValue = getTotalValue();\n        if (portfolioValue == 0) return (0, 0, true);\n        uint256 totalStablecoinValue = _getTotalStablecoinValue();\n        stablecoinRatio = PortfolioAnalysisLib.calculatePortfolioMetrics(portfolioValue, totalStablecoinValue);\n        isBalanced = _checkIfBalanced(portfolioValue);\n    }\n\n    // ===== EIP-1271 =====\n    bytes4 private constant MAGIC_VALUE = 0x1626ba7e;\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view override returns (bytes4 magicValue) {\n        // Try EIP-191 personal_sign digest first\n        bytes32 ethDigest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\n        (address rec1, ECDSA.RecoverError err1, ) = ECDSA.tryRecover(ethDigest, _signature);\n        if (err1 == ECDSA.RecoverError.NoError && (rec1 == authorizedSigner || rec1 == owner())) {\n            return MAGIC_VALUE;\n        }\n        // Fallback to raw hash (e.g., EIP-712 already-digested input)\n        (address rec2, ECDSA.RecoverError err2, ) = ECDSA.tryRecover(_hash, _signature);\n        if (err2 == ECDSA.RecoverError.NoError && (rec2 == authorizedSigner || rec2 == owner())) {\n            return MAGIC_VALUE;\n        }\n        return 0xffffffff;\n    }\n\n    // Helper: contract cannot produce ECDSA signatures on-chain, keep for ABI compatibility\n    function getOrderSignature(bytes32) external pure returns (bytes memory signature) {\n        return bytes(\"\");\n    }\n\n    // ===== Orders (shared) =====\n    event LimitOrderCreated(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n    event RebalanceOrderCreated(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 slippageTolerance\n    );\n\n    function createRebalanceOrder(\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 slippageTolerance\n    ) public onlyOwner returns (bytes32 orderHash) {\n        LimitOrderLib.RebalanceOrder memory rebalanceOrder = LimitOrderLib.RebalanceOrder({\n            sellToken: sellToken,\n            buyToken: buyToken,\n            sellAmount: sellAmount,\n            buyAmount: buyAmount,\n            slippageTolerance: slippageTolerance\n        });\n        ILimitOrderProtocol.Order memory order = LimitOrderLib.createRebalanceOrder(\n            rebalanceOrder,\n            address(this),\n            nonce++,\n            block.timestamp + 3600\n        );\n        orderHash = LimitOrderLib.calculateOrderHash(order, domainSeparator);\n        emit RebalanceOrderCreated(orderHash, address(this), sellToken, buyToken, sellAmount, buyAmount, slippageTolerance);\n    }\n\n    function createStablecoinGridOrder(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        uint256 limitPrice\n    ) public onlyOwner returns (bytes32 orderHash) {\n        ILimitOrderProtocol.Order memory order = LimitOrderLib.createLimitOrder(\n            address(this),\n            address(this),\n            fromToken,\n            toToken,\n            amount,\n            (amount * limitPrice) / 1e18,\n            nonce++,\n            true,\n            false,\n            block.timestamp + 3600\n        );\n        orderHash = LimitOrderLib.calculateOrderHash(order, domainSeparator);\n        emit LimitOrderCreated(orderHash, address(this), fromToken, toToken, amount, (amount * limitPrice) / 1e18);\n    }\n\n    // ===== Portfolio helpers shared =====\n    function _getTotalStablecoinValue() internal view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            address stablecoin = stablecoins[i];\n            uint256 balance = IERC20(stablecoin).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 price = IOracleAdapter(factory.priceFeed()).getRateToEth(stablecoin, false);\n                totalValue += (balance * price) / 1e18;\n            }\n        }\n        return totalValue;\n    }\n\n    function _checkIfBalanced(uint256 portfolioValue) internal view returns (bool) {\n        for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n            AssetGroup memory group = assetGroups[groupId];\n            uint256 groupValue = 0;\n            for (uint256 i = 0; i < group.tokens.length; i++) {\n                uint256 balance = IERC20(group.tokens[i]).balanceOf(address(this));\n                groupValue += getPrice(group.tokens[i], balance);\n            }\n            uint256 currentPercentage = (groupValue * 100) / portfolioValue;\n            uint256 targetPercentage = group.percentage;\n            (bool withinRange, ) = PortfolioAnalysisLib.checkAssetBalance(currentPercentage, targetPercentage);\n            if (!withinRange) return false;\n        }\n        return true;\n    }\n\n    function getAssetAddresses() external view returns (address[] memory) {\n        return assetAddresses;\n    }\n\n    function getStablecoins() external view returns (address[] memory) {\n        return stablecoins;\n    }\n\n    function getAssetGroup(uint256 groupId) external view returns (AssetGroup memory) {\n        return assetGroups[groupId];\n    }\n\n    function getAssetBalance(address _asset) external view returns (uint256) {\n        return IERC20(_asset).balanceOf(address(this));\n    }\n\n    function _isValidAsset(address _asset) internal view returns (bool) {\n        for (uint256 i = 0; i < assetAddresses.length; i++) {\n            if (assetAddresses[i] == _asset) return true;\n        }\n        return false;\n    }\n\n    function _updateAssetGroupMapping(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        address[] memory _stablecoins\n    ) internal {\n        require(_percentages.length > 0, \"No percentages provided\");\n        require(_assetAddresses.length > 0, \"No assets provided\");\n\n        uint256 nonStablecoinCount = 0;\n        uint256 stablecoinCount = 0;\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            bool isStable = false;\n            for (uint256 j = 0; j < _stablecoins.length; j++) {\n                if (_assetAddresses[i] == _stablecoins[j]) {\n                    isStable = true;\n                    stablecoinCount++;\n                    break;\n                }\n            }\n            if (!isStable) {\n                nonStablecoinCount++;\n            }\n        }\n        uint256 expectedPercentageCount = (stablecoinCount > 0 ? 1 : 0) + nonStablecoinCount;\n        require(_percentages.length == expectedPercentageCount, \"Wrong percentage count for asset groups\");\n\n        for (uint256 i2 = 0; i2 < assetGroupsCount; i2++) {\n            delete assetGroups[i2];\n        }\n        assetAddresses = _assetAddresses;\n        assetGroupsCount = 0;\n\n        if (stablecoinCount > 0) {\n            address[] memory stablecoinAssets = new address[](stablecoinCount);\n            uint256 stablecoinIndex = 0;\n            for (uint256 i3 = 0; i3 < _assetAddresses.length; i3++) {\n                for (uint256 j2 = 0; j2 < _stablecoins.length; j2++) {\n                    if (_assetAddresses[i3] == _stablecoins[j2]) {\n                        stablecoinAssets[stablecoinIndex] = _assetAddresses[i3];\n                        stablecoinIndex++;\n                        break;\n                    }\n                }\n            }\n            assetGroups[assetGroupsCount] = AssetGroup({ percentage: _percentages[0], tokens: stablecoinAssets, isStablecoinGroup: true });\n            assetGroupsCount++;\n        }\n\n        uint256 percentageIndex = stablecoinCount > 0 ? 1 : 0;\n        for (uint256 i4 = 0; i4 < _assetAddresses.length; i4++) {\n            bool isStable2 = false;\n            for (uint256 j3 = 0; j3 < _stablecoins.length; j3++) {\n                if (_assetAddresses[i4] == _stablecoins[j3]) {\n                    isStable2 = true;\n                    break;\n                }\n            }\n            if (!isStable2) {\n                address[] memory singleAsset = new address[](1);\n                singleAsset[0] = _assetAddresses[i4];\n                assetGroups[assetGroupsCount] = AssetGroup({ percentage: _percentages[percentageIndex], tokens: singleAsset, isStablecoinGroup: false });\n                assetGroupsCount++;\n                percentageIndex++;\n            }\n        }\n    }\n}\n\n"
    },
    "contracts/portfolio/balancers/DriftBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IOracleAdapter.sol\";\nimport \"../interfaces/IBalancerFactory.sol\";\n\nimport \"../libraries/StablecoinGridLib.sol\";\nimport \"../libraries/PortfolioAnalysisLib.sol\";\nimport \"../libraries/StablecoinAnalysisLib.sol\";\nimport \"./BaseBalancer.sol\";\n\ncontract DriftBalancer is BaseBalancer {\n    using SafeERC20 for IERC20;\n\n    // ===== Metadata / Config =====\n    uint256 public driftPercentage;\n    // name/description inherited in base\n\n\n    // ===== Events =====\n    event DriftPercentageUpdated(uint256 newDriftPercentage);\n    event RebalanceNeeded(address[] tokens, uint256[] deviations);\n    event OrdersGenerated(StablecoinGridLib.Order[] orders);\n\n    constructor(\n        address _owner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256 _driftPercentage,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol,\n        string memory _name,\n        string memory _description\n    ) BaseBalancer(_owner, _factory, _assetAddresses, _percentages, _stablecoins, _limitOrderProtocol, _name, _description) {\n        driftPercentage = _driftPercentage;\n    }\n\n    // ===== Owner controls =====\n    function updateDriftPercentage(uint256 _newDriftPercentage) external onlyOwner {\n        driftPercentage = _newDriftPercentage;\n        emit DriftPercentageUpdated(_newDriftPercentage);\n    }\n\n    // ===== Automation hooks =====\n    function _checkUpkeep(bytes calldata /*checkData*/) internal view override returns (bool upkeepNeeded, bytes memory performData) {\n        // Require ~0.1% drift (1e15 in 18 decimals) to trigger upkeep\n        return StablecoinAnalysisLib.detectDeviation(stablecoins, factory.priceFeed(), 1e15);\n    }\n\n    function _performUpkeep(bytes calldata /*performData*/) internal override {\n        uint256 stablecoinValue = StablecoinAnalysisLib.totalStablecoinValue(stablecoins, factory.priceFeed(), address(this));\n        StablecoinGridLib.GridParams memory params = StablecoinGridLib.calculateGridParams(\n            stablecoinValue,\n            5,\n            15\n        );\n        StablecoinGridLib.Order[] memory orders = StablecoinGridLib.generateGridOrders(stablecoins, params);\n        emit OrdersGenerated(orders);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            StablecoinGridLib.Order memory gridOrder = orders[i];\n            bytes32 orderHash = createStablecoinGridOrder(\n                gridOrder.fromToken,\n                gridOrder.toToken,\n                gridOrder.amount,\n                gridOrder.limitPrice\n            );\n            emit LimitOrderCreated(orderHash, address(this), gridOrder.fromToken, gridOrder.toToken, gridOrder.amount, gridOrder.limitPrice);\n        }\n    }\n\n    // ===== Rebalance trigger =====\n    function triggerRebalance() external { _checkAndTriggerRebalance(); }\n\n    function _checkAndTriggerRebalance() internal {\n        uint256 totalValue = getTotalValue();\n        if (totalValue == 0) return;\n\n        uint256[] memory groupDeviations = new uint256[](assetGroupsCount);\n        address[][] memory groupTokens = new address[][](assetGroupsCount);\n        bool rebalanceNeeded = false;\n\n        for (uint256 groupId = 0; groupId < assetGroupsCount; groupId++) {\n            AssetGroup memory group = assetGroups[groupId];\n            uint256 groupValue = 0;\n            for (uint256 i = 0; i < group.tokens.length; i++) {\n                uint256 balance = IERC20(group.tokens[i]).balanceOf(address(this));\n                groupValue += getPrice(group.tokens[i], balance);\n            }\n            uint256 currentPercentage = (groupValue * 100) / totalValue;\n            uint256 targetPercentage = group.percentage;\n            uint256 deviation = currentPercentage > targetPercentage ? currentPercentage - targetPercentage : targetPercentage - currentPercentage;\n            groupDeviations[groupId] = deviation;\n            groupTokens[groupId] = group.tokens;\n            if (deviation > driftPercentage) {\n                rebalanceNeeded = true;\n            }\n            if (group.isStablecoinGroup && group.tokens.length > 1) {\n                address referenceStable = stablecoins.length > 0 ? stablecoins[0] : address(0);\n                (bool need, uint256 devBps) = StablecoinAnalysisLib.computeGroupStablecoinDeviation(\n                    group.tokens,\n                    referenceStable,\n                    factory.priceFeed(),\n                    1e15\n                );\n                if (need) {\n                    rebalanceNeeded = true;\n                    groupDeviations[groupId] = devBps;\n                }\n            }\n        }\n\n        if (rebalanceNeeded) {\n            address[] memory allTokens = new address[](assetAddresses.length);\n            uint256[] memory allDeviations = new uint256[](assetAddresses.length);\n            uint256 tokenIndex = 0;\n            for (uint256 groupId2 = 0; groupId2 < assetGroupsCount; groupId2++) {\n                for (uint256 i3 = 0; i3 < groupTokens[groupId2].length; i3++) {\n                    allTokens[tokenIndex] = groupTokens[groupId2][i3];\n                    allDeviations[tokenIndex] = groupDeviations[groupId2];\n                    tokenIndex++;\n                }\n            }\n            emit RebalanceNeeded(allTokens, allDeviations);\n        }\n    }\n\n    // All order, EIP-1271, and portfolio helpers are inherited from base\n    receive() external payable {}\n}\n"
    },
    "contracts/portfolio/balancers/TimeBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../interfaces/IBalancerFactory.sol\";\nimport \"../interfaces/IOracleAdapter.sol\";\nimport \"../libraries/StablecoinAnalysisLib.sol\";\nimport \"./BaseBalancer.sol\";\n\ncontract TimeBalancer is BaseBalancer {\n    uint256 public interval;\n    uint256 public lastRebalance;\n    string public timeName;\n    string public timeDescription;\n\n    event IntervalUpdated(uint256 newInterval);\n    event RebalanceNeeded(uint256[] allocations, uint256 timestamp);\n\n    constructor(\n        address _owner,\n        address _factory,\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256 _interval,\n        address[] memory _stablecoins,\n        address _limitOrderProtocol,\n        string memory _name,\n        string memory _description\n    ) BaseBalancer(_owner, _factory, _assetAddresses, _percentages, _stablecoins, _limitOrderProtocol, _name, _description) {\n        interval = _interval;\n        lastRebalance = block.timestamp;\n        timeName = _name;\n        timeDescription = _description;\n    }\n\n    function triggerTimeRebalance() external {\n        require(block.timestamp >= lastRebalance + interval, \"Too early\");\n        lastRebalance = block.timestamp;\n\n        // Also detect stablecoin deviations using shared library\n        (bool upkeepNeeded, ) = StablecoinAnalysisLib.detectDeviation(stablecoins, IBalancerFactory(factory).priceFeed(), 1e15);\n        if (upkeepNeeded) {\n            uint256[] memory current = currentAllocations();\n            emit RebalanceNeeded(current, block.timestamp);\n        }\n    }\n\n    // ===== Automation hooks =====\n    function _checkUpkeep(bytes calldata /*checkData*/) internal view override returns (bool upkeepNeeded, bytes memory performData) {\n        // Time-based: upkeep when interval elapsed\n        bool due = block.timestamp >= lastRebalance + interval;\n        if (!due) return (false, bytes(\"\"));\n        return (true, bytes(\"\"));\n    }\n\n    function _performUpkeep(bytes calldata /*performData*/) internal override {\n        // Simply emit that a rebalance is needed because interval elapsed\n        uint256[] memory current = currentAllocations();\n        emit RebalanceNeeded(current, block.timestamp);\n        lastRebalance = block.timestamp;\n    }\n\n    function setRebalanceInterval(uint256 _interval) external onlyOwner {\n        interval = _interval;\n        emit IntervalUpdated(_interval);\n    }\n\n    function updateTimeMetadata(string calldata _name, string calldata _description) external onlyOwner {\n        timeName = _name;\n        timeDescription = _description;\n    }\n\n    function currentAllocations() public view returns (uint256[] memory) {\n        uint256[] memory allocations = new uint256[](assetGroupsCount);\n        for (uint256 i = 0; i < assetGroupsCount; i++) {\n            allocations[i] = assetGroups[i].percentage;\n        }\n        return allocations;\n    }\n}\n"
    },
    "contracts/portfolio/factory/BalancerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/*\n * OptimizedBalancerFactory\n *\n * Optimized factory contract that deploys OptimizedDriftBalancer or OptimizedTimeBalancer\n * instances with reduced contract sizes through library usage.\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../balancers/DriftBalancer.sol\";\nimport \"../balancers/TimeBalancer.sol\";\nimport \"../interfaces/ILimitOrderProtocol.sol\";\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport \"../automation/DriftBalancerLogger.sol\";\n\n// ===== Programmatic Upkeep Registration (file-level types) =====\n// Minimal interfaces based on Chainlink docs\n// https://docs.chain.link/chainlink-automation/guides/register-upkeep-in-contract\nstruct RegistrationParams {\n    string name;\n    bytes encryptedEmail;\n    address upkeepContract;\n    uint32 gasLimit;\n    address adminAddress;\n    uint8 triggerType; // 0 = conditional, 1 = log\n    bytes checkData; // forwarded to checkUpkeep\n    bytes triggerConfig; // 0x for conditional\n    bytes offchainConfig; // optional CBOR config\n    uint96 amount; // LINK amount (in wei) to fund at registration\n}\n\ninterface IAutomationRegistrar {\n    function registerUpkeep(RegistrationParams calldata requestParams) external returns (uint256);\n}\n\n// Minimal registry interface for reading the Forwarder\ninterface IAutomationRegistryMinimal {\n    function getForwarder(uint256 upkeepId) external view returns (address);\n}\n\ncontract BalancerFactory is Ownable {\n    address public priceFeed;\n    address[] public stablecoins;\n    ILimitOrderProtocol public limitOrderProtocol;\n\n    // ===== Chainlink Automation (programmatic registration) =====\n    LinkTokenInterface public linkToken;\n    address public automationRegistrar; // Automation Registrar (v2.1)\n    address public automationRegistry; // Automation Registry (v2.1)\n\n    // balancer => upkeepId (if registered via this factory)\n    mapping(address => uint256) public balancerToUpkeepId;\n\n    constructor(address _priceFeed, address[] memory _stablecoins, address _limitOrderProtocol) Ownable(msg.sender) {\n        priceFeed = _priceFeed;\n        stablecoins = _stablecoins;\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n    }\n\n    /// @dev Lists of deployed drift and time balancers per user\n    mapping(address => address[]) public userDriftBalancers;\n    mapping(address => address[]) public userTimeBalancers;\n\n    /// @dev Emitted when a new balancer is created\n    event BalancerCreated(address indexed owner, address indexed balancer, bool isTimeBased);\n    event PriceFeedUpdated(address priceFeed);\n    event StablecoinsSet(address[] stablecoins);\n    event LimitOrderProtocolUpdated(address limitOrderProtocol);\n    event AutomationAddressesSet(address linkToken, address registrar, address registry);\n    event UpkeepRegistered(address indexed balancer, uint256 indexed upkeepId, address forwarder);\n    event DriftLoggerDeployed(address indexed logger, address indexed targetBalancer);\n\n    error NoStablecoin();\n\n    /**\n     * @notice Create a new OptimizedDriftBalancer\n     */\n    function createDriftBalancer(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256[] memory _amounts,\n        uint256 _driftPercentage,\n        string memory _name,\n        string memory _description\n    ) external returns (address balancer) {\n        _requireAtLeastOneStablecoin(_assetAddresses);\n        _checkUserTokenBalance(_assetAddresses, _amounts);\n\n         balancer = address(new DriftBalancer(\n            msg.sender, \n            address(this), \n            _assetAddresses, \n            _percentages, \n            _driftPercentage, \n            stablecoins,\n            address(limitOrderProtocol),\n            _name,\n            _description\n        ));\n\n        _sendTokensToBalancer(balancer, _assetAddresses, _amounts);\n        userDriftBalancers[msg.sender].push(balancer);\n        emit BalancerCreated(msg.sender, balancer, false);\n    }\n\n    /**\n     * @notice Create a new OptimizedTimeBalancer\n     */\n    function createTimeBalancer(\n        address[] memory _assetAddresses,\n        uint256[] memory _percentages,\n        uint256[] memory _amounts,\n        uint256 interval,\n        string memory _name,\n        string memory _description\n    ) external returns (address balancer) {\n        _requireAtLeastOneStablecoin(_assetAddresses);\n        _checkUserTokenBalance(_assetAddresses, _amounts);\n\n         balancer = address(new TimeBalancer(\n            msg.sender, \n            address(this), \n            _assetAddresses, \n            _percentages, \n            interval, \n            stablecoins,\n            address(limitOrderProtocol),\n            _name,\n            _description\n        ));\n\n        _sendTokensToBalancer(balancer, _assetAddresses, _amounts);\n        userTimeBalancers[msg.sender].push(balancer);\n        emit BalancerCreated(msg.sender, balancer, true);\n    }\n\n    /**\n     * @notice Internal function to send tokens to a newly created balancer\n     */\n    function _sendTokensToBalancer(address balancer, address[] memory tokens, uint256[] memory amounts) internal {\n        require(tokens.length == amounts.length, \"Tokens and amounts length mismatch\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).transferFrom(msg.sender, balancer, amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to check if the asset addresses contain at least one stablecoin\n     * @dev This function is not used in the current implementation as the stablecoins adressess will be hardcoded in the factory\n     */\n    function _requireAtLeastOneStablecoin(address[] memory _assetAddresses) internal view {\n        for (uint i = 0; i < _assetAddresses.length; i++) {\n            for (uint j = 0; j < stablecoins.length; j++) {\n                if (_assetAddresses[i] == stablecoins[j]) {\n                    return;\n                }\n            }\n        }\n        revert NoStablecoin();\n    }\n\n    function _checkUserTokenBalance(address[] memory tokens, uint256[] memory amounts) internal view {\n        require(tokens.length == amounts.length, \"Tokens and amounts length mismatch\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(IERC20(tokens[i]).balanceOf(msg.sender) >= amounts[i], \"Insufficient token balance in factory\");\n        }\n    }\n\n    function setPriceFeed(address _priceFeed) external onlyOwner {\n        priceFeed = _priceFeed;\n        emit PriceFeedUpdated(_priceFeed);\n    }\n\n    function setStablecoins(address[] calldata _stablecoins) external onlyOwner {\n        stablecoins = _stablecoins;\n        emit StablecoinsSet(_stablecoins);\n    }\n\n    function setLimitOrderProtocol(address _limitOrderProtocol) external onlyOwner {\n        limitOrderProtocol = ILimitOrderProtocol(_limitOrderProtocol);\n        emit LimitOrderProtocolUpdated(_limitOrderProtocol);\n    }\n\n    // Note: public dynamic array `stablecoins` already exposes `stablecoins(uint256)` getter\n\n    // ===== Programmatic Upkeep Registration =====\n\n    function setAutomationAddresses(address _linkToken, address _registrar, address _registry) external onlyOwner {\n        linkToken = LinkTokenInterface(_linkToken);\n        automationRegistrar = _registrar;\n        automationRegistry = _registry;\n        emit AutomationAddressesSet(_linkToken, _registrar, _registry);\n    }\n\n    /// @notice Register a log-trigger upkeep for a DriftBalancerLogger (DIA push oracle logs)\n    /// @param balancer The deployed DriftBalancerLogger address\n    /// @param gasLimit max gas for performUpkeep\n    /// @param amountLinkWei initial LINK funding (wei)\n    /// @param emittingContract DIA PushOracleReceiver contract emitting the event\n    /// @param topic0 keccak256(eventSignature). For DIA classic: keccak256(\"OracleUpdate(string,uint128,uint128)\")\n    /// @param filterSelector per Chainlink docs; 0 = no indexed filters\n    /// @param topic1 indexed topic if filtering by key; otherwise 0x\n    /// @param topic2 unused\n    /// @param topic3 unused\n    function registerLogTriggerUpkeep(\n        address balancer,\n        uint32 gasLimit,\n        uint96 amountLinkWei,\n        address emittingContract,\n        bytes32 topic0,\n        uint8 filterSelector,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3\n    ) external onlyOwner returns (uint256 upkeepId) {\n        require(balancer != address(0), \"balancer=0\");\n        require(address(linkToken) != address(0) && automationRegistrar != address(0), \"Automation not set\");\n\n        linkToken.approve(automationRegistrar, amountLinkWei);\n\n        bytes memory trigger = abi.encode(emittingContract, filterSelector, topic0, topic1, topic2, topic3);\n        RegistrationParams memory params = RegistrationParams({\n            name: string(abi.encodePacked(\"1Balancer-Log-\", _shortAddr(balancer))),\n            encryptedEmail: bytes(\"\"),\n            upkeepContract: balancer,\n            gasLimit: gasLimit,\n            adminAddress: owner(),\n            triggerType: 1, // log trigger\n            checkData: bytes(\"\"),\n            triggerConfig: trigger,\n            offchainConfig: bytes(\"\"),\n            amount: amountLinkWei\n        });\n\n        upkeepId = IAutomationRegistrar(automationRegistrar).registerUpkeep(params);\n        require(upkeepId != 0, \"Registrar returned 0\");\n        balancerToUpkeepId[balancer] = upkeepId;\n\n        address forwarder = address(0);\n        if (automationRegistry != address(0)) {\n            try IAutomationRegistryMinimal(automationRegistry).getForwarder(upkeepId) returns (address fwd) {\n                forwarder = fwd;\n            } catch {}\n        }\n        emit UpkeepRegistered(balancer, upkeepId, forwarder);\n    }\n\n    /// @notice Programmatically register a custom-logic upkeep for a deployed balancer\n    /// @dev Approves LINK to registrar and calls registerUpkeep. Optionally sets forwarder if registry is provided.\n    function registerBalancerUpkeep(\n        address balancer,\n        uint32 gasLimit,\n        uint96 amountLinkWei,\n        bytes calldata checkData\n    ) external onlyOwner returns (uint256 upkeepId) {\n        require(balancer != address(0), \"balancer=0\");\n        require(address(linkToken) != address(0) && automationRegistrar != address(0), \"Automation not set\");\n\n        // 1) Approve LINK to the registrar\n        linkToken.approve(automationRegistrar, amountLinkWei);\n\n        // 2) Build params and register\n        RegistrationParams memory params = RegistrationParams({\n            name: string(abi.encodePacked(\"1Balancer-\", _shortAddr(balancer))),\n            encryptedEmail: bytes(\"\") /* 0x */, \n            upkeepContract: balancer,\n            gasLimit: gasLimit,\n            adminAddress: owner(),\n            triggerType: 0, // 0=conditional (TimeBalancer). For DriftBalancerLogger use 1 and pass log trigger config.\n            checkData: checkData,\n            triggerConfig: bytes(\"\") /* 0x */, \n            offchainConfig: bytes(\"\") /* 0x */, \n            amount: amountLinkWei\n        });\n\n        upkeepId = IAutomationRegistrar(automationRegistrar).registerUpkeep(params);\n        require(upkeepId != 0, \"Registrar returned 0\");\n        balancerToUpkeepId[balancer] = upkeepId;\n\n        // 3) If registry is set, fetch forwarder and set it on the balancer\n        address forwarder = address(0);\n        if (automationRegistry != address(0)) {\n            try IAutomationRegistryMinimal(automationRegistry).getForwarder(upkeepId) returns (address fwd) {\n                forwarder = fwd;\n                try DriftBalancer(payable(balancer)).setForwarderAddress(forwarder) {} catch {}\n            } catch {}\n        }\n\n        emit UpkeepRegistered(balancer, upkeepId, forwarder);\n    }\n\n    /// @notice Refresh and set the forwarder on a balancer from a known upkeepId\n    function refreshBalancerForwarder(address balancer) external {\n        uint256 upkeepId = balancerToUpkeepId[balancer];\n        require(upkeepId != 0 && automationRegistry != address(0), \"No upkeep or registry\");\n        address forwarder = IAutomationRegistryMinimal(automationRegistry).getForwarder(upkeepId);\n        DriftBalancer(payable(balancer)).setForwarderAddress(forwarder);\n        emit UpkeepRegistered(balancer, upkeepId, forwarder);\n    }\n\n    // ===== DIA Log-Trigger Drift Logger Deployment =====\n    function createDriftBalancerLogger(\n        address diaPushOracle,\n        address targetBalancer,\n        string[] memory keys,\n        uint256[] memory thresholdsBps\n    ) external onlyOwner returns (address logger) {\n        logger = address(new DriftBalancerLogger(diaPushOracle, targetBalancer, keys, thresholdsBps));\n        emit DriftLoggerDeployed(logger, targetBalancer);\n    }\n\n    function createAndRegisterDriftBalancerLogger(\n        address diaPushOracle,\n        address targetBalancer,\n        string[] memory keys,\n        uint256[] memory thresholdsBps,\n        // registration params\n        uint32 gasLimit,\n        uint96 amountLinkWei,\n        address emittingContract,\n        bytes32 topic0,\n        uint8 filterSelector,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3\n    ) external onlyOwner returns (address logger, uint256 upkeepId) {\n        logger = address(new DriftBalancerLogger(diaPushOracle, targetBalancer, keys, thresholdsBps));\n        emit DriftLoggerDeployed(logger, targetBalancer);\n\n        // Register log trigger upkeep for the newly deployed logger\n        upkeepId = this.registerLogTriggerUpkeep(\n            logger,\n            gasLimit,\n            amountLinkWei,\n            emittingContract,\n            topic0,\n            filterSelector,\n            topic1,\n            topic2,\n            topic3\n        );\n    }\n\n    function _shortAddr(address a) internal pure returns (string memory) {\n        bytes20 b = bytes20(a);\n        bytes memory out = new bytes(4);\n        out[0] = b[18];\n        out[1] = b[19];\n        out[2] = b[0];\n        out[3] = b[1];\n        return string(out);\n    }\n} "
    },
    "contracts/portfolio/interfaces/IBalancerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IBalancerFactory {\n    function priceFeed() external view returns (address);\n    function stablecoins(uint256) external view returns (address);\n}\n"
    },
    "contracts/portfolio/interfaces/IDiaPushOracleReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n// Minimal read interface for DIA Lumina Push Oracle Receiver.\n// https://www.diadata.org/docs/how-to-guides/fetch-price-data/push-based-oracles\ninterface IDiaPushOracleReceiver {\n    function updates(string calldata key) external view returns (uint128 ts, uint128 value);\n}\n\n"
    },
    "contracts/portfolio/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided hash\n     * @param _hash      Hash of the data to be signed\n     * @param _signature Signature byte array associated with _hash\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */ \n    function isValidSignature(\n        bytes32 _hash, \n        bytes memory _signature\n    ) external view returns (bytes4 magicValue);\n} "
    },
    "contracts/portfolio/interfaces/ILimitOrderProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface ILimitOrderProtocol {\n    struct Order {\n        uint256 salt;\n        address maker;\n        address receiver;\n        address makerAsset;\n        address takerAsset;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        uint256 makerTraits;\n    }\n\n    struct TakerTraits {\n        uint256 traits;\n        bytes args;\n    }\n\n    event OrderFilled(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address indexed taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 remainingMakingAmount\n    );\n\n    function fillOrderArgs(\n        Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits calldata takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    function fillContractOrderArgs(\n        Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits calldata takerTraits,\n        bytes calldata args\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\n\n    function cancelOrder(bytes32 orderHash, uint256 makerTraits) external;\n} "
    },
    "contracts/portfolio/interfaces/IOracleAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IOracleAdapter {\n    function getRateToEth(address srcToken, bool useSrcWrappers) external view returns (uint256 weightedRate);\n    function getRate(address srcToken, address dstToken, bool useWrappers) external view returns (uint256 weightedRate);\n}\n\n"
    },
    "contracts/portfolio/libraries/LimitOrderLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../interfaces/ILimitOrderProtocol.sol\";\n\n/**\n * @title LimitOrderLib\n * @dev Library for creating and managing 1inch limit orders\n * @author @ppezzull\n */\nlibrary LimitOrderLib {\n    // Maker traits flags\n    uint256 private constant NO_PARTIAL_FILLS_FLAG = 255;\n    uint256 private constant ALLOW_MULTIPLE_FILLS_FLAG = 254;\n    uint256 private constant NEED_PREINTERACTION_FLAG = 252;\n    uint256 private constant NEED_POSTINTERACTION_FLAG = 251;\n    uint256 private constant NEED_EPOCH_CHECK_FLAG = 250;\n    uint256 private constant HAS_EXTENSION_FLAG = 249;\n    uint256 private constant USE_PERMIT2_FLAG = 248;\n    uint256 private constant UNWRAP_WETH_FLAG = 247;\n\n    // Taker traits flags\n    uint256 private constant MAKER_AMOUNT_FLAG = 255;\n    uint256 private constant UNWRAP_WETH_FLAG_TAKER = 254;\n    uint256 private constant SKIP_ORDER_PERMIT_FLAG = 253;\n    uint256 private constant USE_PERMIT2_FLAG_TAKER = 252;\n    uint256 private constant ARGS_HAS_TARGET = 251;\n\n    struct LimitOrderData {\n        ILimitOrderProtocol.Order order;\n        bytes extension;\n        bytes signature;\n        uint256 orderHash;\n    }\n\n    struct RebalanceOrder {\n        address sellToken;\n        address buyToken;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint256 slippageTolerance; // in basis points (1 = 0.01%)\n    }\n\n    event LimitOrderCreated(\n        bytes32 indexed orderHash,\n        address indexed maker,\n        address sellToken,\n        address buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    /**\n     * @dev Create a basic limit order\n     */\n    function createLimitOrder(\n        address maker,\n        address receiver,\n        address makerAsset,\n        address takerAsset,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 salt,\n        bool allowPartialFills,\n        bool allowMultipleFills,\n        uint256 expiration\n    ) internal pure returns (ILimitOrderProtocol.Order memory order) {\n        uint256 makerTraits = buildMakerTraits(\n            address(0), // allowedSender\n            false, // shouldCheckEpoch\n            allowPartialFills, // allowPartialFill\n            allowMultipleFills, // allowMultipleFills\n            false, // usePermit2\n            false, // unwrapWeth\n            expiration, // expiry\n            0, // nonce\n            0 // series\n        );\n\n        order = ILimitOrderProtocol.Order({\n            salt: salt,\n            maker: maker,\n            receiver: receiver,\n            makerAsset: makerAsset,\n            takerAsset: takerAsset,\n            makingAmount: makingAmount,\n            takingAmount: takingAmount,\n            makerTraits: makerTraits\n        });\n    }\n\n    /**\n     * @dev Create a rebalancing limit order\n     */\n    function createRebalanceOrder(\n        RebalanceOrder memory rebalanceOrder,\n        address maker,\n        uint256 salt,\n        uint256 expiry\n    ) internal pure returns (ILimitOrderProtocol.Order memory order) {\n        order = createLimitOrder(\n            maker, // maker\n            maker, // receiver\n            rebalanceOrder.sellToken, // makerAsset\n            rebalanceOrder.buyToken, // takerAsset\n            rebalanceOrder.sellAmount, // makingAmount\n            rebalanceOrder.buyAmount, // takingAmount\n            salt, // salt\n            true, // allowPartialFills\n            false, // allowMultipleFills\n            expiry // absolute expiration timestamp (e.g., block.timestamp + seconds)\n        );\n    }\n\n    /**\n     * @dev Build maker traits for limit orders\n     */\n    function buildMakerTraits(\n        address allowedSender,\n        bool shouldCheckEpoch,\n        bool allowPartialFill,\n        bool allowMultipleFills,\n        bool usePermit2,\n        bool unwrapWeth,\n        uint256 expiry,\n        uint256 nonce,\n        uint256 series\n    ) internal pure returns (uint256 makerTraits) {\n        // Validate inputs\n        require(expiry < (1 << 40), \"Expiry too large\");\n        require(nonce < (1 << 40), \"Nonce too large\");\n        require(series < (1 << 40), \"Series too large\");\n\n        makerTraits = (series << 160) |\n                     (nonce << 120) |\n                     (expiry << 80) |\n                     (uint256(uint160(allowedSender)) & ((1 << 80) - 1));\n\n        // Set flags\n        if (!allowPartialFill) makerTraits |= (1 << NO_PARTIAL_FILLS_FLAG);\n        if (allowMultipleFills) makerTraits |= (1 << ALLOW_MULTIPLE_FILLS_FLAG);\n        if (shouldCheckEpoch) makerTraits |= (1 << NEED_EPOCH_CHECK_FLAG);\n        if (usePermit2) makerTraits |= (1 << USE_PERMIT2_FLAG);\n        if (unwrapWeth) makerTraits |= (1 << UNWRAP_WETH_FLAG);\n    }\n\n    /**\n     * @dev Build taker traits for order filling\n     */\n    function buildTakerTraits(\n        bool makingAmount,\n        bool unwrapWeth,\n        bool skipMakerPermit,\n        bool usePermit2,\n        address target,\n        bytes memory extension,\n        bytes memory interaction,\n        uint256 threshold\n    ) internal pure returns (ILimitOrderProtocol.TakerTraits memory takerTraits) {\n        uint256 traits = threshold;\n\n        if (makingAmount) traits |= (1 << MAKER_AMOUNT_FLAG);\n        if (unwrapWeth) traits |= (1 << UNWRAP_WETH_FLAG_TAKER);\n        if (skipMakerPermit) traits |= (1 << SKIP_ORDER_PERMIT_FLAG);\n        if (usePermit2) traits |= (1 << USE_PERMIT2_FLAG_TAKER);\n        if (target != address(0)) traits |= (1 << ARGS_HAS_TARGET);\n\n        // Add extension and interaction lengths\n        unchecked {\n            traits |= (uint256(extension.length) << 224);\n            traits |= (uint256(interaction.length) << 200);\n        }\n\n        takerTraits.traits = traits;\n        takerTraits.args = abi.encodePacked(target, extension, interaction);\n    }\n\n    /**\n     * @dev Calculate order hash\n     */\n    function calculateOrderHash(\n        ILimitOrderProtocol.Order memory order,\n        bytes32 domainSeparator\n    ) internal pure returns (bytes32 orderHash) {\n        orderHash = keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator,\n            keccak256(abi.encode(\n                order.salt,\n                order.maker,\n                order.receiver,\n                order.makerAsset,\n                order.takerAsset,\n                order.makingAmount,\n                order.takingAmount,\n                order.makerTraits\n            ))\n        ));\n    }\n\n    /**\n     * @dev Validate order parameters\n     */\n    function validateOrder(ILimitOrderProtocol.Order memory order) internal pure returns (bool) {\n        require(order.maker != address(0), \"Invalid maker\");\n        require(order.makerAsset != address(0), \"Invalid maker asset\");\n        require(order.takerAsset != address(0), \"Invalid taker asset\");\n        require(order.makingAmount > 0, \"Invalid making amount\");\n        require(order.takingAmount > 0, \"Invalid taking amount\");\n        require(order.makerAsset != order.takerAsset, \"Same assets\");\n        \n        return true;\n    }\n\n    /**\n     * @dev Calculate slippage-adjusted amounts\n     */\n    function calculateSlippageAmounts(\n        uint256 baseAmount,\n        uint256 slippageTolerance\n    ) internal pure returns (uint256 minAmount, uint256 maxAmount) {\n        require(slippageTolerance <= 1000, \"Slippage too high\"); // Max 10%\n        \n        uint256 tolerance = (baseAmount * slippageTolerance) / 10000;\n        minAmount = baseAmount - tolerance;\n        maxAmount = baseAmount + tolerance;\n    }\n} "
    },
    "contracts/portfolio/libraries/PortfolioAnalysisLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nlibrary PortfolioAnalysisLib {\n    struct PortfolioData {\n        uint256 portfolioValue;\n        uint256 stablecoinRatio;\n        bool isBalanced;\n        bool rebalanceNeeded;\n    }\n\n    struct AssetAnalysis {\n        address token;\n        uint256 balance;\n        uint256 currentPercentage;\n        uint256 targetPercentage;\n        uint256 deviation;\n        bool withinRange;\n    }\n\n    /**\n     * @dev Check if an asset's balance is within acceptable percentage range\n     */\n    function checkAssetBalance(\n        uint256 currentPercentage,\n        uint256 targetPercentage\n    ) internal pure returns (bool isWithinRange, uint256 deviation) {\n        if (currentPercentage > targetPercentage) {\n            deviation = currentPercentage - targetPercentage;\n        } else {\n            deviation = targetPercentage - currentPercentage;\n        }\n\n        isWithinRange = deviation <= 5; // 5% tolerance\n        return (isWithinRange, deviation);\n    }\n\n    /**\n     * @dev Calculate portfolio metrics\n     */\n    function calculatePortfolioMetrics(\n        uint256 totalValue,\n        uint256 stablecoinValue\n    ) internal pure returns (uint256 stablecoinRatio) {\n        if (totalValue == 0) return 0;\n        unchecked {\n            stablecoinRatio = (stablecoinValue * 10000) / totalValue; // Basis points\n        }\n    }\n}\n"
    },
    "contracts/portfolio/libraries/StablecoinAnalysisLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IOracleAdapter.sol\";\nimport \"../interfaces/IBalancerFactory.sol\";\n\nlibrary StablecoinAnalysisLib {\n    using SafeERC20 for IERC20;\n\n    function detectDeviation(\n        address[] storage stablecoins,\n        address priceFeed,\n        uint256 minDrift\n    ) internal view returns (bool upkeepNeeded, bytes memory performData) {\n        uint256 n = stablecoins.length;\n        if (n <= 1) return (false, bytes(\"\"));\n        address ref = stablecoins[0];\n        unchecked {\n            // Primary: check token -> ref pairs (what tests set)\n            for (uint256 i = 1; i < n; i++) {\n                try IOracleAdapter(priceFeed).getRate(stablecoins[i], ref, false) returns (uint256 p) {\n                    if (p > 1e18 + minDrift || p + minDrift < 1e18) {\n                        return (true, abi.encode(stablecoins[i], ref, p));\n                    }\n                } catch {}\n            }\n            // Secondary: full pairwise scan both directions as fallback\n            for (uint256 i2 = 0; i2 + 1 < n; i2++) {\n                for (uint256 j2 = i2 + 1; j2 < n; j2++) {\n                    try IOracleAdapter(priceFeed).getRate(stablecoins[i2], stablecoins[j2], false) returns (uint256 p1) {\n                        if (p1 > 1e18 + minDrift || p1 + minDrift < 1e18) {\n                            return (true, abi.encode(stablecoins[i2], stablecoins[j2], p1));\n                        }\n                    } catch {}\n                    try IOracleAdapter(priceFeed).getRate(stablecoins[j2], stablecoins[i2], false) returns (uint256 p2) {\n                        if (p2 > 1e18 + minDrift || p2 + minDrift < 1e18) {\n                            return (true, abi.encode(stablecoins[j2], stablecoins[i2], p2));\n                        }\n                    } catch {}\n                }\n            }\n        }\n        return (false, bytes(\"\"));\n    }\n\n    function computeGroupStablecoinDeviation(\n        address[] memory groupTokens,\n        address referenceStable,\n        address priceFeed,\n        uint256 minDrift\n    ) internal view returns (bool rebalanceNeeded, uint256 deviation) {\n        // Pairwise check\n        unchecked {\n            for (uint256 i = 0; i + 1 < groupTokens.length; i++) {\n                for (uint256 j = i + 1; j < groupTokens.length; j++) {\n                uint256 p = IOracleAdapter(priceFeed).getRate(groupTokens[i], groupTokens[j], false);\n                if (p > 1e18 + minDrift || p + minDrift < 1e18) {\n                    rebalanceNeeded = true;\n                    deviation = p > 1e18 ? p - 1e18 : 1e18 - p;\n                }\n                }\n            }\n        }\n        if (referenceStable != address(0)) {\n            for (uint256 k = 0; k < groupTokens.length; k++) {\n                if (groupTokens[k] == referenceStable) continue;\n                uint256 pRef = IOracleAdapter(priceFeed).getRate(groupTokens[k], referenceStable, false);\n                if (pRef > 1e18 + minDrift || pRef + minDrift < 1e18) {\n                    rebalanceNeeded = true;\n                    deviation = pRef > 1e18 ? pRef - 1e18 : 1e18 - pRef;\n                }\n            }\n        }\n    }\n\n    function totalStablecoinValue(\n        address[] storage stablecoins,\n        address priceFeed,\n        address self\n    ) internal view returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < stablecoins.length; i++) {\n            address stablecoin = stablecoins[i];\n            uint256 balance = IERC20(stablecoin).balanceOf(self);\n            if (balance > 0) {\n                uint256 price = IOracleAdapter(priceFeed).getRateToEth(stablecoin, false);\n                totalValue += (balance * price) / 1e18;\n            }\n        }\n        return totalValue;\n    }\n}\n\n\n"
    },
    "contracts/portfolio/libraries/StablecoinGridLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title StablecoinGridLib\n * @dev Grid trading logic for stablecoins extracted from StableLimit\n * @author @ppezzull\n */\nlibrary StablecoinGridLib {\n    struct Order {\n        address fromToken;\n        address toToken;\n        uint256 amount;\n        uint256 limitPrice; // Price with 1e18 precision\n    }\n\n    struct GridParams {\n        uint256 capital;\n        uint256 nLevels;\n        uint256 minOrderSize;\n        uint256 maxOrderSize;\n        uint256 gridRangeBps;\n        uint256 pegPrice;\n    }\n\n    // Constants\n    uint256 private constant PRICE_PRECISION = 1e18;\n    uint256 private constant USDC_DECIMALS = 6;\n\n    // Price bounds for stablecoin deviation detection (wider bounds for testing)\n    // Tighter bounds so a 1% deviation triggers actions (e.g., 0.99 is outside bounds)\n    uint256 internal constant LOWER_BOUND = 995 * 1e15; // 0.995\n    uint256 internal constant UPPER_BOUND = 1005 * 1e15; // 1.005\n\n    /**\n     * @dev Generate grid orders for stablecoin pairs\n     */\n    function generateGridOrders(\n        address[] memory stablecoins,\n        GridParams memory params\n    ) internal pure returns (Order[] memory orders) {\n        if (params.nLevels == 0) return new Order[](0);\n\n        uint256 nPairs = stablecoins.length;\n        if (nPairs < 2) return new Order[](0);\n\n        uint256 nLevelsAdjusted = params.nLevels;\n        uint256 denominator = params.nLevels * 2 * (nPairs - 1);\n        uint256 baseOrderAmount = denominator == 0 ? 0 : params.capital / denominator;\n\n        if (baseOrderAmount < params.minOrderSize) {\n            uint256 denomMin = params.minOrderSize * 2 * (nPairs - 1);\n            nLevelsAdjusted = denomMin == 0 ? 0 : params.capital / denomMin;\n            if (nLevelsAdjusted == 0) nLevelsAdjusted = 1;\n        } else if (baseOrderAmount > params.maxOrderSize) {\n            uint256 denomMax = params.maxOrderSize * 2 * (nPairs - 1);\n            nLevelsAdjusted = denomMax == 0 ? 0 : params.capital / denomMax;\n            uint256 maxLevels = 100;\n            if (nLevelsAdjusted > maxLevels) nLevelsAdjusted = maxLevels;\n        }\n\n        if (nLevelsAdjusted == 0) return new Order[](0);\n\n        uint256 perLevelDenom = nLevelsAdjusted * 2 * (nPairs - 1);\n        uint256 finalOrderAmount = params.capital / perLevelDenom;\n        orders = new Order[](perLevelDenom);\n        uint256 idx = 0;\n        uint256 step = (PRICE_PRECISION * params.gridRangeBps) / 10000;\n        uint256 peg = params.pegPrice;\n\n        unchecked {\n            for (uint256 pair = 0; pair < nPairs - 1; pair++) {\n                address fromToken = stablecoins[pair];\n                address toToken = stablecoins[pair + 1];\n                for (uint256 i = 0; i < nLevelsAdjusted; i++) {\n                    uint256 offset = ((i + 1) * step) / nLevelsAdjusted;\n                    orders[idx++] = Order(fromToken, toToken, finalOrderAmount, peg + offset);\n                    orders[idx++] = Order(toToken, fromToken, finalOrderAmount, peg - offset);\n                }\n            }\n        }\n\n        return orders;\n    }\n\n    /**\n     * @dev Check if price is within acceptable bounds\n     */\n    function isPriceWithinBounds(uint256 price) internal pure returns (bool) {\n        return price >= LOWER_BOUND && price <= UPPER_BOUND;\n    }\n\n    /**\n     * @dev Calculate grid order parameters\n     */\n    function calculateGridParams(\n        uint256 stablecoinValue,\n        uint256 nLevels,\n        uint256 gridRangeBps\n    ) internal pure returns (GridParams memory params) {\n        params.capital = stablecoinValue / 10; // Use 10% of stablecoin value\n        params.nLevels = nLevels;\n        params.minOrderSize = 10 * (10 ** USDC_DECIMALS); // 10 USDC\n        params.maxOrderSize = params.capital;\n        params.gridRangeBps = gridRangeBps;\n        params.pegPrice = 1 * PRICE_PRECISION; // 1 USD for stablecoins\n    }\n\n    /**\n     * @dev Validate stablecoin pair for grid trading\n     */\n    function validateStablecoinPair(\n        address token1,\n        address token2,\n        mapping(address => bool) storage isStablecoin\n    ) external view returns (bool) {\n        return isStablecoin[token1] && isStablecoin[token2] && token1 != token2;\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}