{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "maker",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "sellToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sellAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "buyAmount",
          "type": "uint256"
        }
      ],
      "name": "LimitOrderCreated",
      "type": "event"
    }
  ],
  "transactionHash": "0x39a9a8e1937a51ecb8eb93aefec4e0e08d41ced267058d0b264392c149ae0052",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "66028",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa44a23c8b3a8497f9c62346d98fcc089a939541538e9c6aa5d4e6b42352e9877",
    "transactionHash": "0x39a9a8e1937a51ecb8eb93aefec4e0e08d41ced267058d0b264392c149ae0052",
    "logs": [],
    "blockNumber": 1,
    "cumulativeGasUsed": "66028",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a9676a96c68143630148e71508d4d26e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"LimitOrderCreated\",\"type\":\"event\"}],\"devdoc\":{\"author\":\"@ppezzull\",\"details\":\"Library for creating and managing 1inch limit orders\",\"kind\":\"dev\",\"methods\":{},\"title\":\"LimitOrderLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/portfolio/libraries/LimitOrderLib.sol\":\"LimitOrderLib\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/portfolio/interfaces/ILimitOrderProtocol.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\ninterface ILimitOrderProtocol {\\n    struct Order {\\n        uint256 salt;\\n        address maker;\\n        address receiver;\\n        address makerAsset;\\n        address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        uint256 makerTraits;\\n    }\\n\\n    struct TakerTraits {\\n        uint256 traits;\\n        bytes args;\\n    }\\n\\n    event OrderFilled(\\n        bytes32 indexed orderHash,\\n        address indexed maker,\\n        address indexed taker,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount\\n    );\\n\\n    function fillOrderArgs(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits calldata takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits calldata takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    function cancelOrder(bytes32 orderHash, uint256 makerTraits) external;\\n} \",\"keccak256\":\"0xcc296f803611ff5cef2f3e8bf47df596281248e08abf67441abcd8ab83646861\",\"license\":\"MIT\"},\"contracts/portfolio/libraries/LimitOrderLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"../interfaces/ILimitOrderProtocol.sol\\\";\\n\\n/**\\n * @title LimitOrderLib\\n * @dev Library for creating and managing 1inch limit orders\\n * @author @ppezzull\\n */\\nlibrary LimitOrderLib {\\n    // Maker traits flags\\n    uint256 private constant NO_PARTIAL_FILLS_FLAG = 255;\\n    uint256 private constant ALLOW_MULTIPLE_FILLS_FLAG = 254;\\n    uint256 private constant NEED_PREINTERACTION_FLAG = 252;\\n    uint256 private constant NEED_POSTINTERACTION_FLAG = 251;\\n    uint256 private constant NEED_EPOCH_CHECK_FLAG = 250;\\n    uint256 private constant HAS_EXTENSION_FLAG = 249;\\n    uint256 private constant USE_PERMIT2_FLAG = 248;\\n    uint256 private constant UNWRAP_WETH_FLAG = 247;\\n\\n    // Taker traits flags\\n    uint256 private constant MAKER_AMOUNT_FLAG = 255;\\n    uint256 private constant UNWRAP_WETH_FLAG_TAKER = 254;\\n    uint256 private constant SKIP_ORDER_PERMIT_FLAG = 253;\\n    uint256 private constant USE_PERMIT2_FLAG_TAKER = 252;\\n    uint256 private constant ARGS_HAS_TARGET = 251;\\n\\n    struct LimitOrderData {\\n        ILimitOrderProtocol.Order order;\\n        bytes extension;\\n        bytes signature;\\n        uint256 orderHash;\\n    }\\n\\n    struct RebalanceOrder {\\n        address sellToken;\\n        address buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint256 slippageTolerance; // in basis points (1 = 0.01%)\\n    }\\n\\n    event LimitOrderCreated(\\n        bytes32 indexed orderHash,\\n        address indexed maker,\\n        address sellToken,\\n        address buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount\\n    );\\n\\n    /**\\n     * @dev Create a basic limit order\\n     */\\n    function createLimitOrder(\\n        address maker,\\n        address receiver,\\n        address makerAsset,\\n        address takerAsset,\\n        uint256 makingAmount,\\n        uint256 takingAmount,\\n        uint256 salt,\\n        bool allowPartialFills,\\n        bool allowMultipleFills,\\n        uint256 expiration\\n    ) internal pure returns (ILimitOrderProtocol.Order memory order) {\\n        uint256 makerTraits = buildMakerTraits(\\n            address(0), // allowedSender\\n            false, // shouldCheckEpoch\\n            allowPartialFills, // allowPartialFill\\n            allowMultipleFills, // allowMultipleFills\\n            false, // usePermit2\\n            false, // unwrapWeth\\n            expiration, // expiry\\n            0, // nonce\\n            0 // series\\n        );\\n\\n        order = ILimitOrderProtocol.Order({\\n            salt: salt,\\n            maker: maker,\\n            receiver: receiver,\\n            makerAsset: makerAsset,\\n            takerAsset: takerAsset,\\n            makingAmount: makingAmount,\\n            takingAmount: takingAmount,\\n            makerTraits: makerTraits\\n        });\\n    }\\n\\n    /**\\n     * @dev Create a rebalancing limit order\\n     */\\n    function createRebalanceOrder(\\n        RebalanceOrder memory rebalanceOrder,\\n        address maker,\\n        uint256 salt,\\n        uint256 expiry\\n    ) internal pure returns (ILimitOrderProtocol.Order memory order) {\\n        order = createLimitOrder(\\n            maker, // maker\\n            maker, // receiver\\n            rebalanceOrder.sellToken, // makerAsset\\n            rebalanceOrder.buyToken, // takerAsset\\n            rebalanceOrder.sellAmount, // makingAmount\\n            rebalanceOrder.buyAmount, // takingAmount\\n            salt, // salt\\n            true, // allowPartialFills\\n            false, // allowMultipleFills\\n            expiry // absolute expiration timestamp (e.g., block.timestamp + seconds)\\n        );\\n    }\\n\\n    /**\\n     * @dev Build maker traits for limit orders\\n     */\\n    function buildMakerTraits(\\n        address allowedSender,\\n        bool shouldCheckEpoch,\\n        bool allowPartialFill,\\n        bool allowMultipleFills,\\n        bool usePermit2,\\n        bool unwrapWeth,\\n        uint256 expiry,\\n        uint256 nonce,\\n        uint256 series\\n    ) internal pure returns (uint256 makerTraits) {\\n        // Validate inputs\\n        require(expiry < (1 << 40), \\\"Expiry too large\\\");\\n        require(nonce < (1 << 40), \\\"Nonce too large\\\");\\n        require(series < (1 << 40), \\\"Series too large\\\");\\n\\n        makerTraits = (series << 160) |\\n                     (nonce << 120) |\\n                     (expiry << 80) |\\n                     (uint256(uint160(allowedSender)) & ((1 << 80) - 1));\\n\\n        // Set flags\\n        if (!allowPartialFill) makerTraits |= (1 << NO_PARTIAL_FILLS_FLAG);\\n        if (allowMultipleFills) makerTraits |= (1 << ALLOW_MULTIPLE_FILLS_FLAG);\\n        if (shouldCheckEpoch) makerTraits |= (1 << NEED_EPOCH_CHECK_FLAG);\\n        if (usePermit2) makerTraits |= (1 << USE_PERMIT2_FLAG);\\n        if (unwrapWeth) makerTraits |= (1 << UNWRAP_WETH_FLAG);\\n    }\\n\\n    /**\\n     * @dev Build taker traits for order filling\\n     */\\n    function buildTakerTraits(\\n        bool makingAmount,\\n        bool unwrapWeth,\\n        bool skipMakerPermit,\\n        bool usePermit2,\\n        address target,\\n        bytes memory extension,\\n        bytes memory interaction,\\n        uint256 threshold\\n    ) internal pure returns (ILimitOrderProtocol.TakerTraits memory takerTraits) {\\n        uint256 traits = threshold;\\n\\n        if (makingAmount) traits |= (1 << MAKER_AMOUNT_FLAG);\\n        if (unwrapWeth) traits |= (1 << UNWRAP_WETH_FLAG_TAKER);\\n        if (skipMakerPermit) traits |= (1 << SKIP_ORDER_PERMIT_FLAG);\\n        if (usePermit2) traits |= (1 << USE_PERMIT2_FLAG_TAKER);\\n        if (target != address(0)) traits |= (1 << ARGS_HAS_TARGET);\\n\\n        // Add extension and interaction lengths\\n        unchecked {\\n            traits |= (uint256(extension.length) << 224);\\n            traits |= (uint256(interaction.length) << 200);\\n        }\\n\\n        takerTraits.traits = traits;\\n        takerTraits.args = abi.encodePacked(target, extension, interaction);\\n    }\\n\\n    /**\\n     * @dev Calculate order hash\\n     */\\n    function calculateOrderHash(\\n        ILimitOrderProtocol.Order memory order,\\n        bytes32 domainSeparator\\n    ) internal pure returns (bytes32 orderHash) {\\n        orderHash = keccak256(abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            domainSeparator,\\n            keccak256(abi.encode(\\n                order.salt,\\n                order.maker,\\n                order.receiver,\\n                order.makerAsset,\\n                order.takerAsset,\\n                order.makingAmount,\\n                order.takingAmount,\\n                order.makerTraits\\n            ))\\n        ));\\n    }\\n\\n    /**\\n     * @dev Validate order parameters\\n     */\\n    function validateOrder(ILimitOrderProtocol.Order memory order) internal pure returns (bool) {\\n        require(order.maker != address(0), \\\"Invalid maker\\\");\\n        require(order.makerAsset != address(0), \\\"Invalid maker asset\\\");\\n        require(order.takerAsset != address(0), \\\"Invalid taker asset\\\");\\n        require(order.makingAmount > 0, \\\"Invalid making amount\\\");\\n        require(order.takingAmount > 0, \\\"Invalid taking amount\\\");\\n        require(order.makerAsset != order.takerAsset, \\\"Same assets\\\");\\n        \\n        return true;\\n    }\\n\\n    /**\\n     * @dev Calculate slippage-adjusted amounts\\n     */\\n    function calculateSlippageAmounts(\\n        uint256 baseAmount,\\n        uint256 slippageTolerance\\n    ) internal pure returns (uint256 minAmount, uint256 maxAmount) {\\n        require(slippageTolerance <= 1000, \\\"Slippage too high\\\"); // Max 10%\\n        \\n        uint256 tolerance = (baseAmount * slippageTolerance) / 10000;\\n        minAmount = baseAmount - tolerance;\\n        maxAmount = baseAmount + tolerance;\\n    }\\n} \",\"keccak256\":\"0x0c64520d996cbd5b7c902af13ddab01e6e7f3e7f7dec21508092507d3d471286\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea2646970667358221220f6d9e24e7cac8a5ad2a35704910833421ef7bdea32cead660c1f979dc183c57564736f6c63430008170033",
  "deployedBytecode": "0x600080fdfea2646970667358221220f6d9e24e7cac8a5ad2a35704910833421ef7bdea32cead660c1f979dc183c57564736f6c63430008170033",
  "devdoc": {
    "author": "@ppezzull",
    "details": "Library for creating and managing 1inch limit orders",
    "kind": "dev",
    "methods": {},
    "title": "LimitOrderLib",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}